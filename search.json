{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"jsonl","text":"<p> A lightweight, dependency-free Python library for reading, writing, and streaming JSON Lines data. </p> <p> </p> <p>jsonl provides a simple, Pythonic API for working with JSON Lines data. It follows the conventions of Python's standard <code>json</code> module ‚Äî if you know <code>json.dump</code> and <code>json.load</code>, you already know how to use jsonl.</p> <p>Fully compliant with the JSON Lines and NDJSON specifications.</p>","path":["jsonl"],"tags":[]},{"location":"#why-jsonl","level":2,"title":"Why jsonl?","text":"<p>The JSON Lines format is ideal for processing large volumes of structured data line by line, without loading everything into memory. jsonl lets you work with this format effortlessly, offering a familiar API inspired by Python's standard <code>json</code> module ‚Äî with zero external dependencies.</p>","path":["jsonl"],"tags":[]},{"location":"#features","level":2,"title":"Features","text":"Feature Description üåé Familiar API Interface similar to the standard <code>json</code> module (<code>dump</code>, <code>load</code>, <code>dumps</code>) ‚ö° Streaming by default Read and write incrementally via iterators, keeping memory usage low üóúÔ∏è Built-in compression Transparent support for <code>gzip</code>, <code>bzip2</code>, and <code>xz</code> üì¶ Archive support Read and write <code>ZIP</code> and <code>TAR</code> archives (<code>.tar.gz</code>, <code>.tar.bz2</code>, <code>.tar.xz</code>) üì• Load from URLs Pass a URL directly to <code>load()</code> or <code>load_archive()</code> üöÄ Pluggable serialization Swap in <code>orjson</code>, <code>ujson</code>, or any JSON library üîß Error tolerance Optionally skip malformed lines instead of crashing üêç Zero dependencies Uses only the Python standard library ‚Äî nothing else","path":["jsonl"],"tags":[]},{"location":"#quick-start","level":2,"title":"Quick Start","text":"","path":["jsonl"],"tags":[]},{"location":"#install","level":3,"title":"Install","text":"<pre><code>pip install py-jsonl\n</code></pre> <p>Note</p> <p>Requires Python 3.8 or higher. No external dependencies needed.</p>","path":["jsonl"],"tags":[]},{"location":"#write-data","level":3,"title":"Write data","text":"<pre><code>import jsonl\n\ndata = [\n    {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7‚ô£\"], [\"one pair\", \"10‚ô•\"]]},\n    {\"name\": \"May\", \"wins\": []},\n]\n\njsonl.dump(data, \"players.jsonl\")\n</code></pre>","path":["jsonl"],"tags":[]},{"location":"#read-data","level":3,"title":"Read data","text":"<pre><code>import jsonl\n\nfor item in jsonl.load(\"players.jsonl\"):\n    print(item)\n</code></pre>","path":["jsonl"],"tags":[]},{"location":"#read-from-a-url","level":3,"title":"Read from a URL","text":"<pre><code>import jsonl\n\nfor item in jsonl.load(\"https://example.com/data.jsonl\"):\n    print(item)\n</code></pre>","path":["jsonl"],"tags":[]},{"location":"#compressed-files","level":3,"title":"Compressed files","text":"<p>The compression format is detected automatically ‚Äî by file extension when writing, and by magic numbers when reading:</p> <pre><code>import jsonl\n\ndata = [{\"key\": \"value\"}]\n\njsonl.dump(data, \"file.jsonl.gz\")     # gzip\njsonl.dump(data, \"file.jsonl.bz2\")    # bzip2\njsonl.dump(data, \"file.jsonl.xz\")     # xz\n\nfor item in jsonl.load(\"file.jsonl.gz\"):\n    print(item)\n</code></pre>","path":["jsonl"],"tags":[]},{"location":"#archives-zip-tar","level":3,"title":"Archives (ZIP / TAR)","text":"<pre><code>import jsonl\n\n# Write multiple files into an archive\ndata = [\n    (\"users.jsonl\", [{\"name\": \"Alice\", \"age\": 30}, {\"name\": \"Bob\", \"age\": 25}]),\n    (\"orders.jsonl\", [{\"id\": 1, \"total\": 99.90}, {\"id\": 2, \"total\": 45.00}]),\n]\njsonl.dump_archive(\"data.tar.gz\", data)\n\n# Read them back\nfor filename, items in jsonl.load_archive(\"data.tar.gz\"):\n    print(f\"--- {filename} ---\")\n    for item in items:\n        print(item)\n</code></pre>","path":["jsonl"],"tags":[]},{"location":"#api-overview","level":2,"title":"API Overview","text":"","path":["jsonl"],"tags":[]},{"location":"#reading","level":3,"title":"Reading","text":"Function Description <code>jsonl.load</code> Read a file, URL, or file-like object as an iterator of objects <code>jsonl.load_archive</code> Read JSON Lines files from a ZIP or TAR archive","path":["jsonl"],"tags":[]},{"location":"#writing","level":3,"title":"Writing","text":"Function Description <code>jsonl.dump</code> Write an iterable of objects to a JSON Lines file <code>jsonl.dumps</code> Serialize an iterable into a JSON Lines string <code>jsonl.dump_fork</code> Write to multiple JSON Lines files simultaneously <code>jsonl.dump_archive</code> Pack multiple JSON Lines files into a ZIP or TAR archive <p>Custom Serialization</p> <p>All write functions accept <code>json_dumps</code> and <code>**json_dumps_kwargs</code> for custom serialization. All read functions accept <code>json_loads</code> and <code>**json_loads_kwargs</code> for custom deserialization.</p>","path":["jsonl"],"tags":[]},{"location":"#supported-formats","level":2,"title":"Supported Formats","text":"Type Extensions Plain <code>.jsonl</code> Compressed <code>.jsonl.gz</code>, <code>.jsonl.bz2</code>, <code>.jsonl.xz</code> ZIP archive <code>.zip</code> TAR archive <code>.tar</code>, <code>.tar.gz</code>, <code>.tar.bz2</code>, <code>.tar.xz</code> <p>Info</p> <p>When reading, if the file extension is not recognized, jsonl falls back to magic-number detection to identify the compression format automatically.</p>","path":["jsonl"],"tags":[]},{"location":"#license","level":2,"title":"License","text":"<p>MIT ‚Äî see LICENSE for details.</p>","path":["jsonl"],"tags":[]},{"location":"changes/","level":1,"title":"Changelog","text":"<p>All notable changes to this project are documented in the CHANGELOG.md file on GitHub.</p>","path":["Changelog"],"tags":[]},{"location":"changes/#latest-releases","level":2,"title":"Latest Releases","text":"","path":["Changelog"],"tags":[]},{"location":"changes/#v1322","level":3,"title":"v1.3.22","text":"<ul> <li>Improved documentation examples for <code>json.dump</code> and <code>json.load</code> keyword arguments.</li> <li>Enabled additional <code>ruff</code> linting rules and passed all checks.</li> <li>Enhanced docstrings with full <code>sphinx-linter</code> compliance.</li> </ul>","path":["Changelog"],"tags":[]},{"location":"changes/#v1321","level":3,"title":"v1.3.21","text":"<ul> <li>Added <code>sphinx-linter</code> and <code>pymport</code> linters to CI/CD pipeline.</li> <li>Updated <code>README.md</code> badges for better visibility.</li> </ul>","path":["Changelog"],"tags":[]},{"location":"changes/#v1320","level":3,"title":"v1.3.20","text":"<ul> <li>Added support for Python 3.14.</li> </ul>","path":["Changelog"],"tags":[]},{"location":"changes/#v1319","level":3,"title":"v1.3.19","text":"<ul> <li>Improved compression detection: <code>load_archive</code> and <code>load</code> now use magic-number detection as fallback.</li> </ul>","path":["Changelog"],"tags":[]},{"location":"changes/#v1318","level":3,"title":"v1.3.18","text":"<ul> <li>Replaced deprecated <code>urllib.request.urlretrieve</code> with modern alternative.</li> </ul>","path":["Changelog"],"tags":[]},{"location":"changes/#v1317","level":3,"title":"v1.3.17","text":"<ul> <li><code>load_archive</code> now supports loading directly from URLs.</li> <li>Added acceptance tests for URL-based loading with a local HTTP server.</li> </ul>","path":["Changelog"],"tags":[]},{"location":"changes/#v1316","level":3,"title":"v1.3.16","text":"<ul> <li><code>load</code> now supports loading directly from URLs.</li> <li><code>dump_archive</code> and <code>dump_fork</code> now accept <code>pathlib.Path</code> objects.</li> </ul>","path":["Changelog"],"tags":[]},{"location":"changes/#v1314","level":3,"title":"v1.3.14","text":"<ul> <li>Added <code>dump_archive</code> function for writing archives.</li> </ul>","path":["Changelog"],"tags":[]},{"location":"changes/#v1313","level":3,"title":"v1.3.13","text":"<ul> <li>Added <code>load_archive</code> function for reading archives.</li> <li>Reached 100% test coverage.</li> </ul> <p>For the complete history, see the full changelog on GitHub.</p>","path":["Changelog"],"tags":[]},{"location":"dump/","level":1,"title":"jsonl.dump","text":"<p>Write an iterable of objects to a JSON Lines file. Supports filenames (with automatic compression), <code>os.PathLike</code> objects, and file-like objects with <code>write</code> or <code>writelines</code> methods.</p>","path":["API Reference","Writing","jsonl.dump"],"tags":[]},{"location":"dump/#function-signature","level":2,"title":"Function Signature","text":"<pre><code>jsonl.dump(\n    iterable,\n    file,\n    *,\n    opener=None,\n    text_mode=True,\n    json_dumps=None,\n    **json_dumps_kwargs,\n)\n</code></pre>","path":["API Reference","Writing","jsonl.dump"],"tags":[]},{"location":"dump/#parameters","level":3,"title":"Parameters","text":"Parameter Type Default Description <code>iterable</code> <code>Iterable[Any]</code> (required) Iterable of JSON-serializable objects <code>file</code> <code>str</code>, <code>PathLike</code>, file-like (required) Destination file path or file-like object <code>opener</code> <code>Callable</code> or <code>None</code> <code>None</code> Custom function to open the file (used only when <code>file</code> is a path) <code>text_mode</code> <code>bool</code> <code>True</code> If <code>False</code>, write bytes instead of text <code>json_dumps</code> <code>Callable</code> or <code>None</code> <code>None</code> Custom serialization function. Defaults to <code>json.dumps</code> <code>**json_dumps_kwargs</code> Additional keyword arguments passed to the serialization function","path":["API Reference","Writing","jsonl.dump"],"tags":[]},{"location":"dump/#raises","level":3,"title":"Raises","text":"Exception Condition <code>ValueError</code> If the file object is missing both <code>writelines</code> and <code>write</code> methods","path":["API Reference","Writing","jsonl.dump"],"tags":[]},{"location":"dump/#compression-detection","level":3,"title":"Compression Detection","text":"<p>Note</p> <p>Supported compression formats: gzip (.gz), bzip2 (.bz2), xz (.xz)</p> <p>When a filename is provided, the compression format is determined by its extension. If the extension is not recognized, the file is written as plain text.</p>","path":["API Reference","Writing","jsonl.dump"],"tags":[]},{"location":"dump/#examples","level":2,"title":"Examples","text":"","path":["API Reference","Writing","jsonl.dump"],"tags":[]},{"location":"dump/#write-to-a-file","level":3,"title":"Write to a file","text":"<pre><code>import jsonl\n\ndata = [\n    {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7‚ô£\"], [\"one pair\", \"10‚ô•\"]]},\n    {\"name\": \"May\", \"wins\": []},\n]\n\njsonl.dump(data, \"file.jsonl\")\n</code></pre>","path":["API Reference","Writing","jsonl.dump"],"tags":[]},{"location":"dump/#write-to-a-compressed-file","level":3,"title":"Write to a compressed file","text":"<pre><code>import jsonl\n\ndata = [\n    {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7‚ô£\"], [\"one pair\", \"10‚ô•\"]]},\n    {\"name\": \"May\", \"wins\": []},\n]\n\njsonl.dump(data, \"file.jsonl.gz\")    # gzip\njsonl.dump(data, \"file.jsonl.bz2\")   # bzip2\njsonl.dump(data, \"file.jsonl.xz\")    # xz\n</code></pre>","path":["API Reference","Writing","jsonl.dump"],"tags":[]},{"location":"dump/#write-to-an-open-file-object","level":3,"title":"Write to an open file object","text":"<p>Tip</p> <p>Useful when you need fine-grained control over how the file is opened, or when appending to an existing file.</p> <pre><code>import gzip\nimport jsonl\n\ndata = [\n    {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7‚ô£\"], [\"one pair\", \"10‚ô•\"]]},\n    {\"name\": \"May\", \"wins\": []},\n]\n\n# Text file\nwith open(\"file.jsonl\", mode=\"wt\", encoding=\"utf-8\") as fd:\n    jsonl.dump(data, fd, text_mode=True)\n\n# Binary compressed file\nwith gzip.open(\"file.jsonl.gz\", mode=\"wb\") as fd:\n    jsonl.dump(data, fd, text_mode=False)\n</code></pre>","path":["API Reference","Writing","jsonl.dump"],"tags":[]},{"location":"dump/#append-to-an-existing-file","level":3,"title":"Append to an existing file","text":"<pre><code>import gzip\nimport jsonl\n\ndata = [\n    {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7‚ô£\"], [\"one pair\", \"10‚ô•\"]]},\n    {\"name\": \"May\", \"wins\": []},\n]\n\n# Append to a compressed file\nwith gzip.open(\"file.jsonl.gz\", mode=\"ab\") as fp:\n    jsonl.dump(data, fp, text_mode=False)\n\n# Append to an uncompressed file\nwith open(\"file.jsonl\", mode=\"at\", encoding=\"utf-8\") as fp:\n    jsonl.dump(data, fp, text_mode=True)\n</code></pre>","path":["API Reference","Writing","jsonl.dump"],"tags":[]},{"location":"dump/#write-to-a-custom-file-object","level":3,"title":"Write to a custom file object","text":"<p>Tip</p> <p>The custom file object must implement a <code>write</code> or <code>writelines</code> method.</p> <pre><code>import jsonl\n\n\nclass MyWriter:\n    \"\"\"A custom file object with a writelines method.\"\"\"\n\n    def writelines(self, lines):\n        for line in lines:\n            print(line, end=\"\")\n\n\ndata = [{\"name\": \"Alice\"}, {\"name\": \"Bob\"}]\n\njsonl.dump(data, MyWriter(), text_mode=True)\n</code></pre>","path":["API Reference","Writing","jsonl.dump"],"tags":[]},{"location":"dump/#custom-serialization","level":3,"title":"Custom serialization","text":"","path":["API Reference","Writing","jsonl.dump"],"tags":[]},{"location":"dump/#using-a-third-party-library","level":4,"title":"Using a third-party library","text":"<p><code>orjson</code> is a high-performance JSON library that returns bytes:</p> <pre><code>import orjson\nimport jsonl\n\ndata = [\n    {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7‚ô£\"], [\"one pair\", \"10‚ô•\"]]},\n    {\"name\": \"May\", \"wins\": []},\n]\n\n# orjson returns bytes ‚Äî set text_mode=False\njsonl.dump(data, \"file.jsonl\", json_dumps=orjson.dumps, text_mode=False)\n</code></pre> <p><code>ujson</code> is another popular alternative:</p> <pre><code>import ujson\nimport jsonl\n\ndata = [{\"name\": \"Alice\"}, {\"name\": \"Bob\"}]\n\njsonl.dump(data, \"file.jsonl\", json_dumps=ujson.dumps, ensure_ascii=False)\n</code></pre>","path":["API Reference","Writing","jsonl.dump"],"tags":[]},{"location":"dump/#passing-additional-keyword-arguments","level":4,"title":"Passing additional keyword arguments","text":"<p>Extra keyword arguments are forwarded directly to the serialization function (by default, <code>json.dumps</code>):</p> <pre><code>import jsonl\n\ndata = [{\"name\": \"Alice\", \"score\": 9.5}, {\"name\": \"Bob\", \"score\": 7.2}]\n\n# Compact output (minimal whitespace)\njsonl.dump(data, \"compact.jsonl\", separators=(\",\", \":\"))\n\n# Sorted keys for deterministic output\njsonl.dump(data, \"sorted.jsonl\", sort_keys=True)\n</code></pre>","path":["API Reference","Writing","jsonl.dump"],"tags":[]},{"location":"dump_archive/","level":1,"title":"jsonl.dump_archive","text":"<p>Write multiple JSON Lines files into a ZIP or TAR archive. Supports compressed TAR variants and custom serialization.</p>","path":["API Reference","Writing","jsonl.dump_archive"],"tags":[]},{"location":"dump_archive/#function-signature","level":2,"title":"Function Signature","text":"<pre><code>jsonl.dump_archive(\n    path,\n    data,\n    *,\n    opener=None,\n    text_mode=True,\n    dump_if_empty=True,\n    json_dumps=None,\n    **json_dumps_kwargs,\n)\n</code></pre>","path":["API Reference","Writing","jsonl.dump_archive"],"tags":[]},{"location":"dump_archive/#parameters","level":3,"title":"Parameters","text":"Parameter Type Default Description <code>path</code> <code>str</code> (required) Destination path for the archive file <code>data</code> <code>Iterable[tuple[str, Iterable[Any]]]</code> (required) Iterable of <code>(relative_path, items)</code> tuples <code>opener</code> <code>Callable</code> or <code>None</code> <code>None</code> Custom function to open the given file paths <code>text_mode</code> <code>bool</code> <code>True</code> If <code>False</code>, write bytes instead of text <code>dump_if_empty</code> <code>bool</code> <code>True</code> If <code>False</code>, don't create empty files or an empty archive <code>json_dumps</code> <code>Callable</code> or <code>None</code> <code>None</code> Custom serialization function. Defaults to <code>json.dumps</code> <code>**json_dumps_kwargs</code> Additional keyword arguments passed to the serialization function","path":["API Reference","Writing","jsonl.dump_archive"],"tags":[]},{"location":"dump_archive/#returns","level":3,"title":"Returns","text":"<p><code>str</code> or <code>None</code> ‚Äî Path to the created archive file, or <code>None</code> if no items were written and <code>dump_if_empty</code> is <code>False</code>.</p>","path":["API Reference","Writing","jsonl.dump_archive"],"tags":[]},{"location":"dump_archive/#supported-archive-formats","level":3,"title":"Supported Archive Formats","text":"Extension Format <code>.zip</code> ZIP <code>.tar</code> TAR (uncompressed) <code>.tar.gz</code> TAR + gzip <code>.tar.bz2</code> TAR + bzip2 <code>.tar.xz</code> TAR + xz <p>Warning</p> <p>If the archive already exists at the given path, it will be overwritten.</p> <p>Note</p> <ul> <li>Paths in the <code>data</code> argument must be relative. Absolute paths will raise a <code>ValueError</code>.</li> <li>If <code>data</code> contains multiple items for the same path, they are appended to the corresponding file within the archive.</li> </ul>","path":["API Reference","Writing","jsonl.dump_archive"],"tags":[]},{"location":"dump_archive/#examples","level":2,"title":"Examples","text":"","path":["API Reference","Writing","jsonl.dump_archive"],"tags":[]},{"location":"dump_archive/#create-a-zip-archive","level":3,"title":"Create a ZIP archive","text":"<pre><code>import jsonl\n\ndata = [\n    (\"users.jsonl\", [{\"name\": \"Alice\", \"age\": 30}, {\"name\": \"Bob\", \"age\": 25}]),\n    (\"orders.jsonl\", [{\"id\": 1, \"total\": 99.90}, {\"id\": 2, \"total\": 45.00}]),\n]\n\njsonl.dump_archive(\"archive.zip\", data)\n</code></pre>","path":["API Reference","Writing","jsonl.dump_archive"],"tags":[]},{"location":"dump_archive/#create-a-compressed-tar-archive","level":3,"title":"Create a compressed TAR archive","text":"<pre><code>import jsonl\n\ndata = [\n    (\"users.jsonl\", [{\"name\": \"Alice\", \"age\": 30}]),\n    (\"logs/activity.jsonl\", [{\"event\": \"login\", \"ts\": \"2025-01-01T00:00:00Z\"}]),\n]\n\njsonl.dump_archive(\"archive.tar.gz\", data)\n</code></pre>","path":["API Reference","Writing","jsonl.dump_archive"],"tags":[]},{"location":"dump_archive/#compressed-files-inside-the-archive","level":3,"title":"Compressed files inside the archive","text":"<p>Individual files within the archive can also be compressed:</p> <pre><code>import jsonl\n\ndata = [\n    (\"file1.jsonl\", [{\"name\": \"Alice\", \"age\": 30}, {\"name\": \"Bob\", \"age\": 25}]),\n    (\"path/to/file2.jsonl.gz\", [{\"name\": \"Charlie\", \"age\": 35}]),\n    (\"file1.jsonl\", [{\"name\": \"Eve\", \"age\": 28}]),  # Appends to file1.jsonl\n]\n\njsonl.dump_archive(\"archive.zip\", data)\n</code></pre>","path":["API Reference","Writing","jsonl.dump_archive"],"tags":[]},{"location":"dump_archive/#skip-empty-files","level":3,"title":"Skip empty files","text":"<pre><code>import jsonl\n\ndata = [\n    (\"has_data.jsonl\", [{\"value\": 1}]),\n    (\"empty.jsonl\", []),  # This file won't be created\n]\n\n# With dump_if_empty=False, empty files and empty archives are skipped\nresult = jsonl.dump_archive(\"archive.zip\", data, dump_if_empty=False)\n</code></pre>","path":["API Reference","Writing","jsonl.dump_archive"],"tags":[]},{"location":"dump_fork/","level":1,"title":"jsonl.dump_fork","text":"<p>Write data to multiple JSON Lines files simultaneously. This is useful when you need to split data across different files based on some criteria, while minimizing memory usage through incremental writing.</p>","path":["API Reference","Writing","jsonl.dump_fork"],"tags":[]},{"location":"dump_fork/#function-signature","level":2,"title":"Function Signature","text":"<pre><code>jsonl.dump_fork(\n    paths,\n    *,\n    opener=None,\n    text_mode=True,\n    dump_if_empty=True,\n    json_dumps=None,\n    **json_dumps_kwargs,\n)\n</code></pre>","path":["API Reference","Writing","jsonl.dump_fork"],"tags":[]},{"location":"dump_fork/#parameters","level":3,"title":"Parameters","text":"Parameter Type Default Description <code>paths</code> <code>Iterable[tuple[str, Iterable[Any]]]</code> (required) Iterable of <code>(filepath, items)</code> tuples <code>opener</code> <code>Callable</code> or <code>None</code> <code>None</code> Custom function to open the given file paths <code>text_mode</code> <code>bool</code> <code>True</code> If <code>False</code>, write bytes instead of text <code>dump_if_empty</code> <code>bool</code> <code>True</code> If <code>False</code>, don't create empty files <code>json_dumps</code> <code>Callable</code> or <code>None</code> <code>None</code> Custom serialization function. Defaults to <code>json.dumps</code> <code>**json_dumps_kwargs</code> Additional keyword arguments passed to the serialization function","path":["API Reference","Writing","jsonl.dump_fork"],"tags":[]},{"location":"dump_fork/#behavior","level":3,"title":"Behavior","text":"<ul> <li>If the same filepath appears multiple times, subsequent data is appended to the file.</li> <li>Files can use compression extensions (<code>.gz</code>, <code>.bz2</code>, <code>.xz</code>) and will be compressed accordingly.</li> <li>When <code>dump_if_empty=False</code>, files with no data are not created.</li> </ul>","path":["API Reference","Writing","jsonl.dump_fork"],"tags":[]},{"location":"dump_fork/#examples","level":2,"title":"Examples","text":"","path":["API Reference","Writing","jsonl.dump_fork"],"tags":[]},{"location":"dump_fork/#split-data-into-separate-files","level":3,"title":"Split data into separate files","text":"<pre><code>import jsonl\n\n\ndef generate_player_files():\n    \"\"\"Yield (filepath, records) tuples ‚Äî one file per player.\"\"\"\n\n    data = [\n        {\"name\": \"Gilbert\", \"wins\": [{\"hand\": \"straight\", \"card\": \"7‚ô£\"}]},\n        {\"name\": \"May\", \"wins\": [{\"hand\": \"two pair\", \"card\": \"9‚ô†\"}]},\n        {\"name\": \"Gilbert\", \"wins\": [{\"hand\": \"three of a kind\", \"card\": \"A‚ô¶\"}]},\n    ]\n    for player in data:\n        yield (f\"{player['name']}.jsonl\", player[\"wins\"])\n\n\njsonl.dump_fork(generate_player_files())\n# Creates: Gilbert.jsonl (with 2 entries), May.jsonl (with 1 entry)\n</code></pre>","path":["API Reference","Writing","jsonl.dump_fork"],"tags":[]},{"location":"dump_fork/#write-to-multiple-files-with-static-data","level":3,"title":"Write to multiple files with static data","text":"<pre><code>import jsonl\n\ndata = [\n    (\"users.jsonl\", [{\"name\": \"Alice\", \"age\": 30}, {\"name\": \"Bob\", \"age\": 25}]),\n    (\"orders.jsonl\", [{\"id\": 1, \"total\": 99.90}, {\"id\": 2, \"total\": 45.00}]),\n    (\"users.jsonl\", [{\"name\": \"Eve\", \"age\": 28}]),  # Appends to users.jsonl\n]\n\njsonl.dump_fork(data)\n</code></pre>","path":["API Reference","Writing","jsonl.dump_fork"],"tags":[]},{"location":"dump_fork/#custom-serialization","level":3,"title":"Custom serialization","text":"<pre><code>import orjson\nimport jsonl\n\n\ndef worker():\n    yield (\"numbers.jsonl\", ({\"value\": 1}, {\"value\": 2}))\n    yield (\"strings.jsonl\", iter(({\"a\": \"1\"}, {\"b\": \"2\"})))\n    yield (\"numbers.jsonl\", [{\"value\": 3}])\n\n\n# Using orjson for faster serialization\njsonl.dump_fork(worker(), json_dumps=orjson.dumps, text_mode=False)\n</code></pre>","path":["API Reference","Writing","jsonl.dump_fork"],"tags":[]},{"location":"dumps/","level":1,"title":"jsonl.dumps","text":"<p>Serialize an iterable of objects into a JSON Lines formatted string.</p>","path":["API Reference","Writing","jsonl.dumps"],"tags":[]},{"location":"dumps/#function-signature","level":2,"title":"Function Signature","text":"<pre><code>jsonl.dumps(\n    iterable,\n    *,\n    json_dumps=None,\n    **json_dumps_kwargs,\n)\n</code></pre>","path":["API Reference","Writing","jsonl.dumps"],"tags":[]},{"location":"dumps/#parameters","level":3,"title":"Parameters","text":"Parameter Type Default Description <code>iterable</code> <code>Iterable[Any]</code> (required) Iterable of objects to serialize <code>json_dumps</code> <code>Callable</code> or <code>None</code> <code>None</code> Custom serialization function. Defaults to <code>json.dumps</code> <code>**json_dumps_kwargs</code> Additional keyword arguments passed to the serialization function","path":["API Reference","Writing","jsonl.dumps"],"tags":[]},{"location":"dumps/#returns","level":3,"title":"Returns","text":"<p><code>str</code> ‚Äî A string with one JSON object per line.</p>","path":["API Reference","Writing","jsonl.dumps"],"tags":[]},{"location":"dumps/#examples","level":2,"title":"Examples","text":"","path":["API Reference","Writing","jsonl.dumps"],"tags":[]},{"location":"dumps/#basic-usage","level":3,"title":"Basic usage","text":"<pre><code>import jsonl\n\ndata = [{\"foo\": 1}, {\"bar\": 2}]\nresult = jsonl.dumps(data)\nprint(result)\n</code></pre> <p>Output:</p> <pre><code>{\"foo\": 1}\n{\"bar\": 2}\n</code></pre>","path":["API Reference","Writing","jsonl.dumps"],"tags":[]},{"location":"dumps/#with-custom-serialization","level":3,"title":"With custom serialization","text":"<pre><code>import jsonl\n\ndata = [{\"name\": \"Alice\", \"age\": 30}, {\"name\": \"Bob\", \"age\": 25}]\n\n# Compact output\nresult = jsonl.dumps(data, separators=(\",\", \":\"))\nprint(result)\n</code></pre> <p>Output:</p> <pre><code>{\"name\":\"Alice\",\"age\":30}\n{\"name\":\"Bob\",\"age\":25}\n</code></pre>","path":["API Reference","Writing","jsonl.dumps"],"tags":[]},{"location":"dumps/#with-sorted-keys","level":3,"title":"With sorted keys","text":"<pre><code>import jsonl\n\ndata = [{\"z\": 1, \"a\": 2}, {\"m\": 3, \"b\": 4}]\n\nresult = jsonl.dumps(data, sort_keys=True)\nprint(result)\n</code></pre> <p>Output:</p> <pre><code>{\"a\": 2, \"z\": 1}\n{\"b\": 4, \"m\": 3}\n</code></pre>","path":["API Reference","Writing","jsonl.dumps"],"tags":[]},{"location":"installation/","level":1,"title":"Installation","text":"","path":["Installation"],"tags":[]},{"location":"installation/#requirements","level":2,"title":"Requirements","text":"<ul> <li>Python 3.8 or higher</li> <li>No external dependencies ‚Äî jsonl uses only the Python standard library</li> </ul>","path":["Installation"],"tags":[]},{"location":"installation/#install-via-pip","level":2,"title":"Install via pip","text":"<pre><code>pip install py-jsonl\n</code></pre> <p>To upgrade to the latest version:</p> <pre><code>pip install py-jsonl --upgrade\n</code></pre>","path":["Installation"],"tags":[]},{"location":"installation/#optional-high-performance-json-libraries","level":2,"title":"Optional: High-Performance JSON Libraries","text":"<p>jsonl works with the standard <code>json</code> module out of the box. For better performance, you can use alternative JSON libraries by passing them via the <code>json_dumps</code> / <code>json_loads</code> parameters:</p> <pre><code>pip install orjson\n</code></pre> <pre><code>import orjson\nimport jsonl\n\ndata = [{\"name\": \"Alice\"}, {\"name\": \"Bob\"}]\n\n# Write using orjson (returns bytes, use text_mode=False)\njsonl.dump(data, \"file.jsonl\", json_dumps=orjson.dumps, text_mode=False)\n\n# Read using orjson\nfor item in jsonl.load(\"file.jsonl\", json_loads=orjson.loads):\n    print(item)\n</code></pre>","path":["Installation"],"tags":[]},{"location":"load/","level":1,"title":"jsonl.load","text":"<p>Deserialize a JSON Lines source into an iterator of Python objects. Supports filenames, URLs, <code>urllib.request.Request</code> objects, and file-like objects.</p>","path":["API Reference","Reading","jsonl.load"],"tags":[]},{"location":"load/#function-signature","level":2,"title":"Function Signature","text":"<pre><code>jsonl.load(\n    source,\n    *,\n    opener=None,\n    broken=False,\n    json_loads=None,\n    **json_loads_kwargs,\n)\n</code></pre>","path":["API Reference","Reading","jsonl.load"],"tags":[]},{"location":"load/#parameters","level":3,"title":"Parameters","text":"Parameter Type Default Description <code>source</code> <code>str</code>, <code>PathLike</code>, <code>URL</code>, <code>Request</code>, file-like (required) The JSON Lines source to read from <code>opener</code> <code>Callable</code> or <code>None</code> <code>None</code> Custom function to open the file (not supported for URLs) <code>broken</code> <code>bool</code> <code>False</code> If <code>True</code>, skip malformed lines and log a warning instead of raising an exception <code>json_loads</code> <code>Callable</code> or <code>None</code> <code>None</code> Custom deserialization function. Defaults to <code>json.loads</code> <code>**json_loads_kwargs</code> Additional keyword arguments passed to the deserialization function","path":["API Reference","Reading","jsonl.load"],"tags":[]},{"location":"load/#returns","level":3,"title":"Returns","text":"<p><code>Iterator[Any]</code> ‚Äî An iterator yielding deserialized Python objects, one per line.</p>","path":["API Reference","Reading","jsonl.load"],"tags":[]},{"location":"load/#compression-detection","level":3,"title":"Compression Detection","text":"<p>Note</p> <p>Supported compression formats: gzip (.gz), bzip2 (.bz2), xz (.xz)</p> <p>The compression format is resolved using two strategies:</p> <ol> <li>By file extension ‚Äî if the file has a recognized extension (<code>.gz</code>, <code>.bz2</code>, <code>.xz</code>), that format is used directly.</li> <li>By magic numbers ‚Äî when the extension is not recognized, jsonl inspects the first bytes of the file    (magic numbers) to auto-detect the compression format.</li> </ol> <p>If neither method identifies a known format, the file is treated as uncompressed.</p>","path":["API Reference","Reading","jsonl.load"],"tags":[]},{"location":"load/#examples","level":2,"title":"Examples","text":"","path":["API Reference","Reading","jsonl.load"],"tags":[]},{"location":"load/#load-from-a-file-path","level":3,"title":"Load from a file path","text":"<pre><code>import jsonl\n\ndata = [\n    {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7‚ô£\"], [\"one pair\", \"10‚ô•\"]]},\n    {\"name\": \"May\", \"wins\": []},\n]\n\njsonl.dump(data, \"file.jsonl\")\n\nfor item in jsonl.load(\"file.jsonl\"):\n    print(item)\n</code></pre>","path":["API Reference","Reading","jsonl.load"],"tags":[]},{"location":"load/#load-from-a-compressed-file","level":3,"title":"Load from a compressed file","text":"<pre><code>import jsonl\n\ndata = [\n    {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7‚ô£\"], [\"one pair\", \"10‚ô•\"]]},\n    {\"name\": \"May\", \"wins\": []},\n]\n\n# Write to a gzip-compressed file\njsonl.dump(data, \"file.jsonl.gz\")\n\n# Load automatically detects the compression format\nfor item in jsonl.load(\"file.jsonl.gz\"):\n    print(item)\n</code></pre>","path":["API Reference","Reading","jsonl.load"],"tags":[]},{"location":"load/#load-from-an-open-file-object","level":3,"title":"Load from an open file object","text":"<p>Tip</p> <p>Useful when you need to read from a custom source or control how the file is opened.</p> <pre><code>import jsonl\n\ndata = [\n    {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7‚ô£\"], [\"one pair\", \"10‚ô•\"]]},\n    {\"name\": \"May\", \"wins\": []},\n]\n\njsonl.dump(data, \"file.jsonl\")\n\nwith open(\"file.jsonl\") as fp:\n    for item in jsonl.load(fp):\n        print(item)\n</code></pre>","path":["API Reference","Reading","jsonl.load"],"tags":[]},{"location":"load/#load-from-a-url","level":3,"title":"Load from a URL","text":"<p>You can load JSON Lines directly from a remote URL. For custom request headers, use <code>urllib.request.Request</code>:</p> <pre><code>import urllib.request\nimport jsonl\n\n# Load directly from a URL\nfor item in jsonl.load(\"https://example.com/file.jsonl\"):\n    print(item)\n\n# Load using a custom request with headers\nreq = urllib.request.Request(\n    \"https://example.com/file.jsonl\",\n    headers={\"Accept\": \"application/jsonl\"},\n)\nfor item in jsonl.load(req):\n    print(item)\n</code></pre>","path":["API Reference","Reading","jsonl.load"],"tags":[]},{"location":"load/#handle-broken-lines","level":3,"title":"Handle broken lines","text":"<p>Warning</p> <p>When <code>broken=False</code> (the default), an exception is raised on the first malformed line. When <code>broken=True</code>, malformed lines are skipped and a warning is logged.</p> <pre><code>import jsonl\n\n# Create a file with a broken JSON line\nwith open(\"file.jsonl\", mode=\"wt\", encoding=\"utf-8\") as fp:\n    fp.write('{\"name\": \"Gilbert\"}\\n')\n    fp.write('{\"name\": \"May\", \"wins\": []\\n')  # Missing closing brace\n    fp.write('{\"name\": \"Richard\"}\\n')\n\n# Skip broken lines\nfor item in jsonl.load(\"file.jsonl\", broken=True):\n    print(item)\n</code></pre> <p>Output:</p> <pre><code>WARNING:jsonl:Broken line at 2: Expecting ',' delimiter: line 2 column 1 (char 28)\n{'name': 'Gilbert'}\n{'name': 'Richard'}\n</code></pre>","path":["API Reference","Reading","jsonl.load"],"tags":[]},{"location":"load/#custom-deserialization","level":3,"title":"Custom deserialization","text":"","path":["API Reference","Reading","jsonl.load"],"tags":[]},{"location":"load/#using-a-third-party-library","level":4,"title":"Using a third-party library","text":"<p><code>orjson</code> is a popular high-performance JSON library:</p> <pre><code>import orjson\nimport jsonl\n\ndata = [\n    {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7‚ô£\"], [\"one pair\", \"10‚ô•\"]]},\n    {\"name\": \"May\", \"wins\": []},\n]\n\njsonl.dump(data, \"file.jsonl\")\n\nfor item in jsonl.load(\"file.jsonl\", json_loads=orjson.loads):\n    print(item)\n</code></pre>","path":["API Reference","Reading","jsonl.load"],"tags":[]},{"location":"load/#passing-additional-keyword-arguments","level":4,"title":"Passing additional keyword arguments","text":"<p>Extra keyword arguments are forwarded to the deserialization function (by default, <code>json.loads</code>). For example, parse float values as <code>decimal.Decimal</code>:</p> <pre><code>import decimal\nimport jsonl\n\ndata = [\n    {\"name\": \"Gilbert\", \"wins_avg\": 2.5},\n    {\"name\": \"May\", \"wins_avg\": 3.75},\n]\n\njsonl.dump(data, \"file.jsonl\")\n\nfor item in jsonl.load(\"file.jsonl\", parse_float=decimal.Decimal):\n    print(item)\n    # float values are now decimal.Decimal instances\n</code></pre>","path":["API Reference","Reading","jsonl.load"],"tags":[]},{"location":"load/#custom-opener","level":3,"title":"Custom opener","text":"<p>The <code>opener</code> parameter lets you control how the file is opened. For example, reading from a ZIP archive:</p> <pre><code>import zipfile\nimport jsonl\n\ndata = [\n    {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7‚ô£\"], [\"one pair\", \"10‚ô•\"]]},\n    {\"name\": \"May\", \"wins\": []},\n]\n\n# Create a ZIP archive containing a jsonl file\njsonl.dump(data, \"file.jsonl\")\nwith zipfile.ZipFile(\"data.zip\", \"w\") as zf:\n    zf.write(\"file.jsonl\")\n\n\ndef opener(name, *args, **kwargs):\n    return zipfile.ZipFile(name).open(\"file.jsonl\")\n\n\nfor item in jsonl.load(\"data.zip\", opener=opener):\n    print(item)\n</code></pre>","path":["API Reference","Reading","jsonl.load"],"tags":[]},{"location":"load_archive/","level":1,"title":"jsonl.load_archive","text":"<p>Load multiple JSON Lines files from a ZIP or TAR archive incrementally.</p>","path":["API Reference","Reading","jsonl.load_archive"],"tags":[]},{"location":"load_archive/#function-signature","level":2,"title":"Function Signature","text":"<pre><code>jsonl.load_archive(\n    file,\n    *,\n    pattern=\"*.jsonl\",\n    pwd=None,\n    opener=None,\n    broken=False,\n    json_loads=None,\n    **json_loads_kwargs,\n)\n</code></pre>","path":["API Reference","Reading","jsonl.load_archive"],"tags":[]},{"location":"load_archive/#parameters","level":3,"title":"Parameters","text":"Parameter Type Default Description <code>file</code> <code>str</code>, <code>PathLike</code>, <code>URL</code>, <code>Request</code>, file-like (required) Archive file to load from <code>pattern</code> <code>str</code> <code>\"*.jsonl\"</code> Unix shell-style wildcard pattern to filter filenames inside the archive <code>pwd</code> <code>bytes</code> or <code>None</code> <code>None</code> Password to decrypt the archive (ZIP only) <code>opener</code> <code>Callable</code> or <code>None</code> <code>None</code> Custom function to open the file (not supported for URLs) <code>broken</code> <code>bool</code> <code>False</code> If <code>True</code>, skip malformed lines and log a warning <code>json_loads</code> <code>Callable</code> or <code>None</code> <code>None</code> Custom deserialization function. Defaults to <code>json.loads</code> <code>**json_loads_kwargs</code> Additional keyword arguments passed to the deserialization function","path":["API Reference","Reading","jsonl.load_archive"],"tags":[]},{"location":"load_archive/#returns","level":3,"title":"Returns","text":"<p><code>Iterator[tuple[str, Iterator[Any]]]</code> ‚Äî An iterator of <code>(filename, items)</code> tuples, where <code>items</code> is an iterator of deserialized objects.</p>","path":["API Reference","Reading","jsonl.load_archive"],"tags":[]},{"location":"load_archive/#supported-archive-formats","level":3,"title":"Supported Archive Formats","text":"<ul> <li>ZIP archives (<code>.zip</code>)</li> <li>TAR archives (<code>.tar</code>), including compressed variants: <code>.tar.gz</code>, <code>.tar.bz2</code>, <code>.tar.xz</code></li> </ul>","path":["API Reference","Reading","jsonl.load_archive"],"tags":[]},{"location":"load_archive/#key-features","level":3,"title":"Key Features","text":"<ul> <li>Load from local files or remote URLs</li> <li>Filter files inside the archive using Unix shell-style wildcards</li> <li>Support for compressed <code>.jsonl</code> files inside the archive (e.g., <code>.jsonl.gz</code>, <code>.jsonl.bz2</code>, <code>.jsonl.xz</code>).   Check compression detection for details.</li> <li>ZIP archives with password protection</li> <li>Graceful handling of malformed lines via the <code>broken</code> parameter</li> </ul>","path":["API Reference","Reading","jsonl.load_archive"],"tags":[]},{"location":"load_archive/#examples","level":2,"title":"Examples","text":"","path":["API Reference","Reading","jsonl.load_archive"],"tags":[]},{"location":"load_archive/#load-from-a-local-archive","level":3,"title":"Load from a local archive","text":"<pre><code>import jsonl\n\nfor filename, items in jsonl.load_archive(\"archive.zip\"):\n    print(f\"--- {filename} ---\")\n    for item in items:\n        print(item)\n</code></pre>","path":["API Reference","Reading","jsonl.load_archive"],"tags":[]},{"location":"load_archive/#load-from-a-remote-archive-url","level":3,"title":"Load from a remote archive (URL)","text":"<p>You can load archives from a URL. For custom request headers, use <code>urllib.request.Request</code>:</p> <pre><code>import urllib.request\nimport jsonl\n\n# Load directly from a URL\nfor filename, items in jsonl.load_archive(\"https://example.com/archive.zip\"):\n    print(f\"--- {filename} ---\")\n    for item in items:\n        print(item)\n\n# Load using a custom request with headers\nreq = urllib.request.Request(\"https://example.com/archive.zip\", headers={\"Accept\": \"application/zip\"})\nfor filename, items in jsonl.load_archive(req):\n    print(f\"--- {filename} ---\")\n    for item in items:\n        print(item)\n</code></pre>","path":["API Reference","Reading","jsonl.load_archive"],"tags":[]},{"location":"load_archive/#filter-files-with-pattern-matching","level":3,"title":"Filter files with pattern matching","text":"<p>Use Unix shell-style wildcards to select specific files within the archive:</p> Pattern Matches <code>*.jsonl</code> All <code>.jsonl</code> files (default) <code>users*.jsonl</code> Files starting with <code>users</code> <code>data/[ab]*.jsonl</code> Files in <code>data/</code> starting with <code>a</code> or <code>b</code> <code>*</code> All files <p>For more details, see the fnmatch documentation.</p> <pre><code>import jsonl\n\n# Load only files matching a specific pattern\nfor filename, items in jsonl.load_archive(\"archive.zip\", pattern=\"users*.jsonl\"):\n    print(f\"--- {filename} ---\")\n    for item in items:\n        print(item)\n</code></pre>","path":["API Reference","Reading","jsonl.load_archive"],"tags":[]}]}