{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"jsonl About jsonl is a library that includes useful tools for working with jsonlines data as described jsonlines Features: \ud83c\udf0e Offers an API similar to Python's standard json module. \ud83d\ude80 Supports custom serialization/deserialization callbacks. By default, it uses the standard json module. \ud83d\udddc\ufe0f Enables compression/decompression using gzip , bzip2 , and xz formats. \ud83d\udd27 Load files containing broken lines, skipping any malformed lines. \ud83d\udce6 Provides a simple API for incremental writing to multiple files. Installation (via pip) pip install py-jsonl","title":"Introduction"},{"location":"#jsonl","text":"","title":"jsonl"},{"location":"#about","text":"jsonl is a library that includes useful tools for working with jsonlines data as described jsonlines Features: \ud83c\udf0e Offers an API similar to Python's standard json module. \ud83d\ude80 Supports custom serialization/deserialization callbacks. By default, it uses the standard json module. \ud83d\udddc\ufe0f Enables compression/decompression using gzip , bzip2 , and xz formats. \ud83d\udd27 Load files containing broken lines, skipping any malformed lines. \ud83d\udce6 Provides a simple API for incremental writing to multiple files.","title":"About"},{"location":"#installation-via-pip","text":"pip install py-jsonl","title":"Installation (via pip)"},{"location":"changes/","text":"Can see changes here","title":"Changes"},{"location":"dump/","text":"Dump an iterable to a JSON Lines file incrementally. Dump JSON Lines (jsonl) files incrementally, supporting both uncompressed and compressed formats and allowing custom serialization and opener callbacks. Dump the data to an uncompressed file at the specified path. import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] jsonl.dump(data, \"file.jsonl\") Dump the data to a compressed file at the specified path. Note Supported compression formats are: gzip (.gz), bzip2 (.bz2), xz (.xz) If a file extension is not provided or is unrecognized, the file will be assumed to be uncompressed. import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Dump to a gzip compressed file. jsonl.dump(data, \"file.jsonl.gz\") # Dump to a bzip2 compressed file. jsonl.dump(data, \"file.jsonl.bz2\") # Dump to a xz compressed file. jsonl.dump(data, \"file.jsonl.xz\") # Dump to a text file because the extension is not recognized. jsonl.dump(data, \"file.jsonl.foo\") Dump the data to the already opened compressed file. import gzip import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Dump to an opened gzip file, text_mode is false because it is a binary file. with gzip.open(\"file.jsonl.gz\", mode=\"wb\") as fp: jsonl.dump(data, fp, text_mode=False) Append the data to the end of the existing compressed file. import gzip import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Text mode is false because it is a binary file. with gzip.open(\"file.jsonl.gz\", mode=\"ab\") as fp: jsonl.dump(data, fp, text_mode=False) Dump the data to a custom file object. Tip Use this feature when you need to write the data to a custom file object. The custom file object must have a write or writelines method. import jsonl class MyCustomFile1: \"\"\"A custom file object that has a write method.\"\"\" def write(self, line): print(line) class MyCustomFile2: \"\"\"A custom file object that has a writelines method.\"\"\" def writelines(self, lines): print(\"\".join(lines)) data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Dump the data to the custom file object using the write method. jsonl.dump(data, MyCustomFile1(), text_mode=True) # Dump the data to the custom file object using the writelines method. jsonl.dump(data, MyCustomFile2(), text_mode=True) Dump data with a custom serialization. The json_dumps parameter allows for custom serialization and must take a Python object and return a JSON-formatted string. The following example shows how to use the json_dumps parameter to serialize data with the orjson and ujson libraries. Make sure to install these libraries to run the example. pip install orjson ujson # Ignore this command if these libraries are already installed. import orjson import ujson import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Dump the data using the ujson library. jsonl.dump(data, \"foo.jsonl\", json_dumps=ujson.dumps, ensure_ascii=False) # Dump the data using the orjson library. jsonl.dump(data, \"var.jsonl\", json_dumps=orjson.dumps)","title":"Dump to a jsonlines file"},{"location":"dump/#dump-an-iterable-to-a-json-lines-file-incrementally","text":"Dump JSON Lines (jsonl) files incrementally, supporting both uncompressed and compressed formats and allowing custom serialization and opener callbacks.","title":"Dump an iterable to a JSON Lines file incrementally."},{"location":"dump/#dump-the-data-to-an-uncompressed-file-at-the-specified-path","text":"import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] jsonl.dump(data, \"file.jsonl\")","title":"Dump the data to an uncompressed file at the specified path."},{"location":"dump/#dump-the-data-to-a-compressed-file-at-the-specified-path","text":"Note Supported compression formats are: gzip (.gz), bzip2 (.bz2), xz (.xz) If a file extension is not provided or is unrecognized, the file will be assumed to be uncompressed. import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Dump to a gzip compressed file. jsonl.dump(data, \"file.jsonl.gz\") # Dump to a bzip2 compressed file. jsonl.dump(data, \"file.jsonl.bz2\") # Dump to a xz compressed file. jsonl.dump(data, \"file.jsonl.xz\") # Dump to a text file because the extension is not recognized. jsonl.dump(data, \"file.jsonl.foo\")","title":"Dump the data to a compressed file at the specified path."},{"location":"dump/#dump-the-data-to-the-already-opened-compressed-file","text":"import gzip import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Dump to an opened gzip file, text_mode is false because it is a binary file. with gzip.open(\"file.jsonl.gz\", mode=\"wb\") as fp: jsonl.dump(data, fp, text_mode=False)","title":"Dump the data to the already opened compressed file."},{"location":"dump/#append-the-data-to-the-end-of-the-existing-compressed-file","text":"import gzip import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Text mode is false because it is a binary file. with gzip.open(\"file.jsonl.gz\", mode=\"ab\") as fp: jsonl.dump(data, fp, text_mode=False)","title":"Append the data to the end of the existing compressed file."},{"location":"dump/#dump-the-data-to-a-custom-file-object","text":"Tip Use this feature when you need to write the data to a custom file object. The custom file object must have a write or writelines method. import jsonl class MyCustomFile1: \"\"\"A custom file object that has a write method.\"\"\" def write(self, line): print(line) class MyCustomFile2: \"\"\"A custom file object that has a writelines method.\"\"\" def writelines(self, lines): print(\"\".join(lines)) data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Dump the data to the custom file object using the write method. jsonl.dump(data, MyCustomFile1(), text_mode=True) # Dump the data to the custom file object using the writelines method. jsonl.dump(data, MyCustomFile2(), text_mode=True)","title":"Dump the data to a custom file object."},{"location":"dump/#dump-data-with-a-custom-serialization","text":"The json_dumps parameter allows for custom serialization and must take a Python object and return a JSON-formatted string. The following example shows how to use the json_dumps parameter to serialize data with the orjson and ujson libraries. Make sure to install these libraries to run the example. pip install orjson ujson # Ignore this command if these libraries are already installed. import orjson import ujson import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Dump the data using the ujson library. jsonl.dump(data, \"foo.jsonl\", json_dumps=ujson.dumps, ensure_ascii=False) # Dump the data using the orjson library. jsonl.dump(data, \"var.jsonl\", json_dumps=orjson.dumps)","title":"Dump data with a custom serialization."},{"location":"dump_fork/","text":"Dump to multiple jsonlines files Dump multiple iterables incrementally to the specified jsonlines file paths, optimizing memory usage. The files can be compressed using gzip , bzip2 , or xz formats. If the file extension is not recognized, it will be dumped to a text file. You can install orjson and ujson to run the following example. pip install orjson ujson # Ignore this command if these libraries are already installed. import orjson import ujson import jsonl def worker(): yield (\"num.jsonl\", ({\"value\": 1}, {\"value\": 2})) yield (\"foo.jsonl\", iter(({\"a\": \"1\"}, {\"b\": 2}))) yield (\"num.jsonl\", [{\"value\": 3}]) yield (\"foo.jsonl\", ()) # Dump the data using the default json.dumps function. jsonl.dump_fork(worker()) # Dump the data using the ujson library. jsonl.dump_fork(worker(), json_dumps=ujson.dumps, ensure_ascii=False) # Dump the data using the orjson library. jsonl.dump_fork(worker(), json_dumps=orjson.dumps) # using (orjson)","title":"Dump to multiple jsonlines files"},{"location":"dump_fork/#dump-to-multiple-jsonlines-files","text":"Dump multiple iterables incrementally to the specified jsonlines file paths, optimizing memory usage. The files can be compressed using gzip , bzip2 , or xz formats. If the file extension is not recognized, it will be dumped to a text file. You can install orjson and ujson to run the following example. pip install orjson ujson # Ignore this command if these libraries are already installed. import orjson import ujson import jsonl def worker(): yield (\"num.jsonl\", ({\"value\": 1}, {\"value\": 2})) yield (\"foo.jsonl\", iter(({\"a\": \"1\"}, {\"b\": 2}))) yield (\"num.jsonl\", [{\"value\": 3}]) yield (\"foo.jsonl\", ()) # Dump the data using the default json.dumps function. jsonl.dump_fork(worker()) # Dump the data using the ujson library. jsonl.dump_fork(worker(), json_dumps=ujson.dumps, ensure_ascii=False) # Dump the data using the orjson library. jsonl.dump_fork(worker(), json_dumps=orjson.dumps) # using (orjson)","title":"Dump to multiple jsonlines files"},{"location":"dumps/","text":"Serialize an iterable into a JSON Lines formatted string. import jsonl data = ({'foo': 1}, {'bar': 2}) result = jsonl.dumps(data) print(result)","title":"Dump to a string"},{"location":"dumps/#serialize-an-iterable-into-a-json-lines-formatted-string","text":"import jsonl data = ({'foo': 1}, {'bar': 2}) result = jsonl.dumps(data) print(result)","title":"Serialize an iterable into a JSON Lines formatted string."},{"location":"installation/","text":"Installation Install jsonl via pip: pip install py-jsonl","title":"Installation"},{"location":"installation/#installation","text":"Install jsonl via pip: pip install py-jsonl","title":"Installation"},{"location":"load/","text":"Load JSON Lines files Load JSON Lines (jsonl) files incrementally, supporting both uncompressed and compressed formats, handling broken lines, and allowing custom deserialization and opener callbacks. Note Supported compression formats are: gzip (.gz), bzip2 (.bz2), xz (.xz) If a file extension is not provided or is unrecognized, the file will be assumed to be uncompressed. Load an uncompressed file given a path. import jsonl path = \"file.jsonl\" # Example data to save in the file data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the jsonl file jsonl.dump(data, path) # Load the file as an iterable iterable = jsonl.load(path) print(tuple(iterable)) Load a compressed file given a path. Check note for more details import jsonl path = \"file.jsonl.gz\" # gzip compressed file, but it can be \".bz2\" or \".xz\" # Example data to save in the file data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the compressed jsonl file jsonl.dump(data, path) # Load the compressed file as an iterable iterable = jsonl.load(path) print(tuple(iterable)) Load a file from an open file object. Tip This is useful when you need to load a file from a custom source. import jsonl path = \"file.jsonl\" # Example data to save in the file data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the compressed jsonl file jsonl.dump(data, path) # Load the file using an open file object with open(path, mode=\"rb\") as fp: iterable = jsonl.load(fp) print(tuple(iterable)) Load a file containing broken lines. Warning If the broken parameter is set to False , the function will raise an Exception when it encounters a broken line. If set to True , the function will skip the broken line, continue reading the file, and log a warning message. import jsonl # Create a file with broken JSON lines with open(\"file.jsonl\", mode=\"wt\", encoding=\"utf-8\") as fp: fp.write('{\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]}\\n') fp.write('{\"name\": \"May\", \"wins\": []\\n') # missing closing bracket fp.write('{\"name\": \"Richard\", \"wins\": []}\\n') # Load the jsonl file, skipping broken lines iterable = jsonl.load(\"file.jsonl\", broken=True) print(tuple(iterable)) Output: WARNING:root:Broken line at 1: Expecting ',' delimiter: line 1 column 69 (char 68) WARNING:root:Broken line at 2: Expecting ',' delimiter: line 2 column 1 (char 28) ({'name': 'Richard', 'wins': []},) Load a file using a custom deserialization. The json_loads parameter allows for custom deserialization and must take a JSON-formatted string as input and return a Python object. Tip Commonly, libraries like orjson or ujson are used for faster performance, or you can implement your own custom deserialization function for specific needs. The following example demonstrates how to use the json_loads parameter to deserialize the data using the orjson and ujson libraries. Make sure to install these libraries to run the example. pip install orjson ujson # Ignore this command if these libraries are already installed. Now, you can use these libraries to load the JSON lines: import orjson import ujson import jsonl path = \"file.jsonl\" # Example data to save in the file data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the jsonl file jsonl.dump(data, path) # Load the file using ujson iterable1 = jsonl.load(path, json_loads=ujson.loads) # Load the file using orjson iterable2 = jsonl.load(path, json_loads=orjson.loads) print(tuple(iterable1)) print(tuple(iterable2)) Load a file using a custom opener. The opener parameter allows loading files from custom sources, such as a ZIP archive. Here\u2019s how to use it: import zipfile import jsonl # Create a ZIP file containing a jsonlines file zip_path = \"data.zip\" jsonl_path = \"file.jsonl\" data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the jsonl file jsonl.dump(data, jsonl_path) # Create a ZIP file and add the jsonl file to it with zipfile.ZipFile(zip_path, 'w') as zf: zf.write(jsonl_path) # Define a custom opener function to read from the ZIP file def opener(name, *args, **kwargs): return zipfile.ZipFile(name).open(jsonl_path) # Load the jsonl file from the ZIP archive using the opener iterable = jsonl.load(zip_path, opener=opener) print(tuple(iterable))","title":"Load jsonlines file"},{"location":"load/#load-json-lines-files","text":"Load JSON Lines (jsonl) files incrementally, supporting both uncompressed and compressed formats, handling broken lines, and allowing custom deserialization and opener callbacks. Note Supported compression formats are: gzip (.gz), bzip2 (.bz2), xz (.xz) If a file extension is not provided or is unrecognized, the file will be assumed to be uncompressed.","title":"Load JSON Lines files"},{"location":"load/#load-an-uncompressed-file-given-a-path","text":"import jsonl path = \"file.jsonl\" # Example data to save in the file data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the jsonl file jsonl.dump(data, path) # Load the file as an iterable iterable = jsonl.load(path) print(tuple(iterable))","title":"Load an uncompressed file given a path."},{"location":"load/#load-a-compressed-file-given-a-path","text":"Check note for more details import jsonl path = \"file.jsonl.gz\" # gzip compressed file, but it can be \".bz2\" or \".xz\" # Example data to save in the file data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the compressed jsonl file jsonl.dump(data, path) # Load the compressed file as an iterable iterable = jsonl.load(path) print(tuple(iterable))","title":"Load a compressed file given a path."},{"location":"load/#load-a-file-from-an-open-file-object","text":"Tip This is useful when you need to load a file from a custom source. import jsonl path = \"file.jsonl\" # Example data to save in the file data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the compressed jsonl file jsonl.dump(data, path) # Load the file using an open file object with open(path, mode=\"rb\") as fp: iterable = jsonl.load(fp) print(tuple(iterable))","title":"Load a file from an open file object."},{"location":"load/#load-a-file-containing-broken-lines","text":"Warning If the broken parameter is set to False , the function will raise an Exception when it encounters a broken line. If set to True , the function will skip the broken line, continue reading the file, and log a warning message. import jsonl # Create a file with broken JSON lines with open(\"file.jsonl\", mode=\"wt\", encoding=\"utf-8\") as fp: fp.write('{\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]}\\n') fp.write('{\"name\": \"May\", \"wins\": []\\n') # missing closing bracket fp.write('{\"name\": \"Richard\", \"wins\": []}\\n') # Load the jsonl file, skipping broken lines iterable = jsonl.load(\"file.jsonl\", broken=True) print(tuple(iterable)) Output: WARNING:root:Broken line at 1: Expecting ',' delimiter: line 1 column 69 (char 68) WARNING:root:Broken line at 2: Expecting ',' delimiter: line 2 column 1 (char 28) ({'name': 'Richard', 'wins': []},)","title":"Load a file containing broken lines."},{"location":"load/#load-a-file-using-a-custom-deserialization","text":"The json_loads parameter allows for custom deserialization and must take a JSON-formatted string as input and return a Python object. Tip Commonly, libraries like orjson or ujson are used for faster performance, or you can implement your own custom deserialization function for specific needs. The following example demonstrates how to use the json_loads parameter to deserialize the data using the orjson and ujson libraries. Make sure to install these libraries to run the example. pip install orjson ujson # Ignore this command if these libraries are already installed. Now, you can use these libraries to load the JSON lines: import orjson import ujson import jsonl path = \"file.jsonl\" # Example data to save in the file data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the jsonl file jsonl.dump(data, path) # Load the file using ujson iterable1 = jsonl.load(path, json_loads=ujson.loads) # Load the file using orjson iterable2 = jsonl.load(path, json_loads=orjson.loads) print(tuple(iterable1)) print(tuple(iterable2))","title":"Load a file using a custom deserialization."},{"location":"load/#load-a-file-using-a-custom-opener","text":"The opener parameter allows loading files from custom sources, such as a ZIP archive. Here\u2019s how to use it: import zipfile import jsonl # Create a ZIP file containing a jsonlines file zip_path = \"data.zip\" jsonl_path = \"file.jsonl\" data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the jsonl file jsonl.dump(data, jsonl_path) # Create a ZIP file and add the jsonl file to it with zipfile.ZipFile(zip_path, 'w') as zf: zf.write(jsonl_path) # Define a custom opener function to read from the ZIP file def opener(name, *args, **kwargs): return zipfile.ZipFile(name).open(jsonl_path) # Load the jsonl file from the ZIP archive using the opener iterable = jsonl.load(zip_path, opener=opener) print(tuple(iterable))","title":"Load a file using a custom opener."}]}