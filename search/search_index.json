{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"jsonl About jsonl is a Python library designed to simplify working with JSON Lines data, adhering to the JSON Lines format . Features: \ud83c\udf0e Provides an API similar to Python's standard json module. \ud83d\ude80 Supports custom (de)serialization via user-defined callbacks. \ud83d\udddc\ufe0f Built-in support for gzip , bzip2 , xz compression formats and ZIP or TAR archives. \ud83d\udd27 Skips malformed lines during file loading. \ud83d\udce5 Loads from URLs, file paths, or file-like objects. Installation (via pip) pip install py-jsonl","title":"Introduction"},{"location":"#jsonl","text":"","title":"jsonl"},{"location":"#about","text":"jsonl is a Python library designed to simplify working with JSON Lines data, adhering to the JSON Lines format . Features: \ud83c\udf0e Provides an API similar to Python's standard json module. \ud83d\ude80 Supports custom (de)serialization via user-defined callbacks. \ud83d\udddc\ufe0f Built-in support for gzip , bzip2 , xz compression formats and ZIP or TAR archives. \ud83d\udd27 Skips malformed lines during file loading. \ud83d\udce5 Loads from URLs, file paths, or file-like objects.","title":"About"},{"location":"#installation-via-pip","text":"pip install py-jsonl","title":"Installation (via pip)"},{"location":"changes/","text":"Can see changes here","title":"Changes"},{"location":"dump/","text":"Dump an iterable to a JSON Lines file incrementally. Dump JSON Lines (jsonl) files incrementally, supporting both uncompressed and compressed formats and allowing custom serialization and opener callbacks. Dump the data to an uncompressed file at the specified path. import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] jsonl.dump(data, \"file.jsonl\") Dump the data to a compressed file at the specified path. Note Supported compression formats are: gzip (.gz), bzip2 (.bz2), xz (.xz) If a file extension is not provided or is unrecognized, the file will be assumed to be uncompressed. import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Dump to a gzip compressed file. jsonl.dump(data, \"file.jsonl.gz\") # Dump to a bzip2 compressed file. jsonl.dump(data, \"file.jsonl.bz2\") # Dump to a xz compressed file. jsonl.dump(data, \"file.jsonl.xz\") # Dump to a text file because the extension is not recognized. jsonl.dump(data, \"file.jsonl.foo\") Dump the data to the already opened file. import gzip import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Dump to an opened file, Text mode is True because it is a text file. with open(\"file.jsonl\", mode=\"wt\", encoding=\"utf-8\") as fd: jsonl.dump(data, fd, text_mode=True) # Dump to an opened gzip file, Text mode is false because it is a binary file. with gzip.open(\"file.jsonl.gz\", mode=\"wb\") as fd: jsonl.dump(data, fd, text_mode=False) Append the data to the end of the existing file. import gzip import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Compressed file: Text mode is false because it is a binary file. with gzip.open(\"file.jsonl.gz\", mode=\"ab\") as fp: jsonl.dump(data, fp, text_mode=False) # Uncompressed file: Text mode is true because it is a text file. with open(\"file.jsonl\", mode=\"at\", encoding=\"utf-8\") as fp: jsonl.dump(data, fp, text_mode=True) Dump the data to a custom file object. Tip Use this feature when you need to write the data to a custom file object. The custom file object must have a write or writelines method. import jsonl class MyCustomFile1: \"\"\"A custom file object that has a write method.\"\"\" def write(self, line): print(line) class MyCustomFile2: \"\"\"A custom file object that has a writelines method.\"\"\" def writelines(self, lines): print(\"\".join(lines)) data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Dump the data to the custom file object using the write method. jsonl.dump(data, MyCustomFile1(), text_mode=True) # Dump the data to the custom file object using the writelines method. jsonl.dump(data, MyCustomFile2(), text_mode=True) Dump data with a custom serialization. The json_dumps parameter allows for custom serialization and must take a Python object and return a JSON-formatted string. The following example shows how to use the json_dumps parameter to serialize data with the orjson and ujson libraries. Make sure to install these libraries to run the example. pip install orjson ujson # Ignore this command if these libraries are already installed. import orjson import ujson import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Dump the data using the ujson library. jsonl.dump(data, \"foo.jsonl\", json_dumps=ujson.dumps, ensure_ascii=False) # Dump the data using the orjson library. jsonl.dump(data, \"var.jsonl\", json_dumps=orjson.dumps) # Dumping data into a JSON file with compact output using separators (',', ':') # to remove unnecessary whitespaces. jsonl.dump(data, \"bar.jsonl\", separators=(',', ':'))","title":"Dump to a jsonlines file"},{"location":"dump/#dump-an-iterable-to-a-json-lines-file-incrementally","text":"Dump JSON Lines (jsonl) files incrementally, supporting both uncompressed and compressed formats and allowing custom serialization and opener callbacks.","title":"Dump an iterable to a JSON Lines file incrementally."},{"location":"dump/#dump-the-data-to-an-uncompressed-file-at-the-specified-path","text":"import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] jsonl.dump(data, \"file.jsonl\")","title":"Dump the data to an uncompressed file at the specified path."},{"location":"dump/#dump-the-data-to-a-compressed-file-at-the-specified-path","text":"Note Supported compression formats are: gzip (.gz), bzip2 (.bz2), xz (.xz) If a file extension is not provided or is unrecognized, the file will be assumed to be uncompressed. import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Dump to a gzip compressed file. jsonl.dump(data, \"file.jsonl.gz\") # Dump to a bzip2 compressed file. jsonl.dump(data, \"file.jsonl.bz2\") # Dump to a xz compressed file. jsonl.dump(data, \"file.jsonl.xz\") # Dump to a text file because the extension is not recognized. jsonl.dump(data, \"file.jsonl.foo\")","title":"Dump the data to a compressed file at the specified path."},{"location":"dump/#dump-the-data-to-the-already-opened-file","text":"import gzip import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Dump to an opened file, Text mode is True because it is a text file. with open(\"file.jsonl\", mode=\"wt\", encoding=\"utf-8\") as fd: jsonl.dump(data, fd, text_mode=True) # Dump to an opened gzip file, Text mode is false because it is a binary file. with gzip.open(\"file.jsonl.gz\", mode=\"wb\") as fd: jsonl.dump(data, fd, text_mode=False)","title":"Dump the data to the already opened file."},{"location":"dump/#append-the-data-to-the-end-of-the-existing-file","text":"import gzip import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Compressed file: Text mode is false because it is a binary file. with gzip.open(\"file.jsonl.gz\", mode=\"ab\") as fp: jsonl.dump(data, fp, text_mode=False) # Uncompressed file: Text mode is true because it is a text file. with open(\"file.jsonl\", mode=\"at\", encoding=\"utf-8\") as fp: jsonl.dump(data, fp, text_mode=True)","title":"Append the data to the end of the existing file."},{"location":"dump/#dump-the-data-to-a-custom-file-object","text":"Tip Use this feature when you need to write the data to a custom file object. The custom file object must have a write or writelines method. import jsonl class MyCustomFile1: \"\"\"A custom file object that has a write method.\"\"\" def write(self, line): print(line) class MyCustomFile2: \"\"\"A custom file object that has a writelines method.\"\"\" def writelines(self, lines): print(\"\".join(lines)) data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Dump the data to the custom file object using the write method. jsonl.dump(data, MyCustomFile1(), text_mode=True) # Dump the data to the custom file object using the writelines method. jsonl.dump(data, MyCustomFile2(), text_mode=True)","title":"Dump the data to a custom file object."},{"location":"dump/#dump-data-with-a-custom-serialization","text":"The json_dumps parameter allows for custom serialization and must take a Python object and return a JSON-formatted string. The following example shows how to use the json_dumps parameter to serialize data with the orjson and ujson libraries. Make sure to install these libraries to run the example. pip install orjson ujson # Ignore this command if these libraries are already installed. import orjson import ujson import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Dump the data using the ujson library. jsonl.dump(data, \"foo.jsonl\", json_dumps=ujson.dumps, ensure_ascii=False) # Dump the data using the orjson library. jsonl.dump(data, \"var.jsonl\", json_dumps=orjson.dumps) # Dumping data into a JSON file with compact output using separators (',', ':') # to remove unnecessary whitespaces. jsonl.dump(data, \"bar.jsonl\", separators=(',', ':'))","title":"Dump data with a custom serialization."},{"location":"dump_archive/","text":"Dump multiple JSON Lines Files into an Archive (ZIP or TAR) incrementally Support ZIP or TAR archives, including compressed TAR archives (e.g., .tar.gz , .tar.bz2 , .tar.xz ). Support for both compressed and uncompressed .jsonl files inside the archive. (e.g., *.jsonl.gz or *.jsonl.bz2 or *.jsonl.xz ). Optional custom serialization and opener callbacks for advanced use cases. Warning If the given archive already exists on the given path, it will be overwritten. Note Paths provided in the items_by_relpath argument must be relative. Absolute paths are not allowed and will raise an error. If items_by_relpath contains multiple items for the same path, they will be appended to the corresponding file within the archive. Example usage: import jsonl data = [ # this will create a new file1.jsonl in the archive (\"file1.jsonl\", [{\"name\": \"Alice\", \"age\": 30}, {\"name\": \"Bob\", \"age\": 25}]), # this will create a new file1.jsonl.gz in the archive (\"path/to/file2.jsonl.gz\", [{\"name\": \"Charlie\", \"age\": 35}, {\"name\": \"David\", \"age\": 40}]), # this will append to the file1.jsonl (\"file1.jsonl\", [{\"name\": \"Eve\", \"age\": 28}]), ] jsonl.dump_archive(\"my_archive.zip\", data)","title":"Dump archive files"},{"location":"dump_archive/#dump-multiple-json-lines-files-into-an-archive-zip-or-tar-incrementally","text":"Support ZIP or TAR archives, including compressed TAR archives (e.g., .tar.gz , .tar.bz2 , .tar.xz ). Support for both compressed and uncompressed .jsonl files inside the archive. (e.g., *.jsonl.gz or *.jsonl.bz2 or *.jsonl.xz ). Optional custom serialization and opener callbacks for advanced use cases. Warning If the given archive already exists on the given path, it will be overwritten. Note Paths provided in the items_by_relpath argument must be relative. Absolute paths are not allowed and will raise an error. If items_by_relpath contains multiple items for the same path, they will be appended to the corresponding file within the archive. Example usage: import jsonl data = [ # this will create a new file1.jsonl in the archive (\"file1.jsonl\", [{\"name\": \"Alice\", \"age\": 30}, {\"name\": \"Bob\", \"age\": 25}]), # this will create a new file1.jsonl.gz in the archive (\"path/to/file2.jsonl.gz\", [{\"name\": \"Charlie\", \"age\": 35}, {\"name\": \"David\", \"age\": 40}]), # this will append to the file1.jsonl (\"file1.jsonl\", [{\"name\": \"Eve\", \"age\": 28}]), ] jsonl.dump_archive(\"my_archive.zip\", data)","title":"Dump multiple JSON Lines Files into an Archive (ZIP or TAR) incrementally"},{"location":"dump_fork/","text":"Dump to multiple jsonlines files Dump multiple iterables incrementally to the specified jsonlines file paths, optimizing memory usage. The files can be compressed using gzip , bzip2 , or xz formats. If the file extension is not recognized, it will be dumped to a text file. Example #1 This example uses jsonl.dump_fork to incrementally write structured data to multiple .jsonl files\u2014one per key (in this case, player name). This helps organize and efficiently store data for separate entities. This example creates individual JSON Lines files for each player, storing their respective wins. import jsonl def generate_win_data(): \"\"\"Yield player wins data for multiple players.\"\"\" data = ( { \"name\": \"Gilbert\", \"wins\": [ {\"hand\": \"straight\", \"card\": \"7\u2663\"}, {\"hand\": \"one pair\", \"card\": \"10\u2665\"}, ] }, { \"name\": \"May\", \"wins\": [ {\"hand\": \"two pair\", \"card\": \"9\u2660\"}, ] }, { \"name\": \"Gilbert\", \"wins\": [ {\"hand\": \"three of a kind\", \"card\": \"A\u2666\"}, ] } ) for player in data: name = player[\"name\"] yield (f\"{name}.jsonl\", player[\"wins\"]) # Write the generated data to files in JSON Lines format jsonl.dump_fork(generate_win_data()) Example #2 This example demonstrates how to dump data using different JSON libraries. You can install orjson and ujson to run the following example. pip install orjson ujson # Ignore this command if these libraries are already installed. import orjson import ujson import jsonl def worker(): yield (\"num.jsonl\", ({\"value\": 1}, {\"value\": 2})) yield (\"foo.jsonl\", iter(({\"a\": \"1\"}, {\"b\": 2}))) yield (\"num.jsonl\", [{\"value\": 3}]) yield (\"foo.jsonl\", ()) # Dump the data using the default json.dumps function. jsonl.dump_fork(worker()) # Dump the data using the ujson library. jsonl.dump_fork(worker(), json_dumps=ujson.dumps, ensure_ascii=False) # Dump the data using the orjson library. jsonl.dump_fork(worker(), json_dumps=orjson.dumps) # using (orjson)","title":"Dump to multiple jsonlines files"},{"location":"dump_fork/#dump-to-multiple-jsonlines-files","text":"Dump multiple iterables incrementally to the specified jsonlines file paths, optimizing memory usage. The files can be compressed using gzip , bzip2 , or xz formats. If the file extension is not recognized, it will be dumped to a text file. Example #1 This example uses jsonl.dump_fork to incrementally write structured data to multiple .jsonl files\u2014one per key (in this case, player name). This helps organize and efficiently store data for separate entities. This example creates individual JSON Lines files for each player, storing their respective wins. import jsonl def generate_win_data(): \"\"\"Yield player wins data for multiple players.\"\"\" data = ( { \"name\": \"Gilbert\", \"wins\": [ {\"hand\": \"straight\", \"card\": \"7\u2663\"}, {\"hand\": \"one pair\", \"card\": \"10\u2665\"}, ] }, { \"name\": \"May\", \"wins\": [ {\"hand\": \"two pair\", \"card\": \"9\u2660\"}, ] }, { \"name\": \"Gilbert\", \"wins\": [ {\"hand\": \"three of a kind\", \"card\": \"A\u2666\"}, ] } ) for player in data: name = player[\"name\"] yield (f\"{name}.jsonl\", player[\"wins\"]) # Write the generated data to files in JSON Lines format jsonl.dump_fork(generate_win_data()) Example #2 This example demonstrates how to dump data using different JSON libraries. You can install orjson and ujson to run the following example. pip install orjson ujson # Ignore this command if these libraries are already installed. import orjson import ujson import jsonl def worker(): yield (\"num.jsonl\", ({\"value\": 1}, {\"value\": 2})) yield (\"foo.jsonl\", iter(({\"a\": \"1\"}, {\"b\": 2}))) yield (\"num.jsonl\", [{\"value\": 3}]) yield (\"foo.jsonl\", ()) # Dump the data using the default json.dumps function. jsonl.dump_fork(worker()) # Dump the data using the ujson library. jsonl.dump_fork(worker(), json_dumps=ujson.dumps, ensure_ascii=False) # Dump the data using the orjson library. jsonl.dump_fork(worker(), json_dumps=orjson.dumps) # using (orjson)","title":"Dump to multiple jsonlines files"},{"location":"dumps/","text":"Serialize an iterable into a JSON Lines formatted string. import jsonl data = ({'foo': 1}, {'bar': 2}) result = jsonl.dumps(data) print(result)","title":"Dump to a string"},{"location":"dumps/#serialize-an-iterable-into-a-json-lines-formatted-string","text":"import jsonl data = ({'foo': 1}, {'bar': 2}) result = jsonl.dumps(data) print(result)","title":"Serialize an iterable into a JSON Lines formatted string."},{"location":"installation/","text":"Installation Install jsonl via pip: pip install py-jsonl --upgrade","title":"Installation"},{"location":"installation/#installation","text":"Install jsonl via pip: pip install py-jsonl --upgrade","title":"Installation"},{"location":"load/","text":"Load JSON Lines files Load JSON Lines (jsonl) files incrementally, supporting both uncompressed and compressed formats, handling broken lines, and allowing custom deserialization and opener callbacks. It also allows loading from URLs and urllib requests. Note Supported compression formats are: gzip (.gz), bzip2 (.bz2), xz (.xz) If a file extension is not provided or is unrecognized, the file will be assumed to be uncompressed. Load an uncompressed file given a path. import jsonl path = \"file.jsonl\" # Example data to save in the file data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the jsonl file jsonl.dump(data, path) # Load the file as an iterator iterator = jsonl.load(path) print(tuple(iterator)) Load a compressed file given a path. Check note for more details import jsonl path = \"file.jsonl.gz\" # gzip compressed file, but it can be \".bz2\" or \".xz\" # Example data to save in the file data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the compressed jsonl file jsonl.dump(data, path) # Load the compressed file as an iterator iterator = jsonl.load(path) print(tuple(iterator)) Load a file from an open file object. Tip This is useful when you need to load a file from a custom source. import jsonl path = \"file.jsonl\" # Example data to save in the file data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the compressed jsonl file jsonl.dump(data, path) # Load the file using an open file object with open(path) as fp: iterator = jsonl.load(fp) print(tuple(iterator)) Load from a URL. You can load a JSON Lines directly from a URL incrementally, if needed you can also create custom requests using urllib.request.Request . import urllib.request import jsonl # Load data from a URL iterator = jsonl.load(\"https://example.com\") print(tuple(iterator)) # Load data from a urllib request to handle custom requests req = urllib.request.Request(\"https://example.com\", headers={\"Accept\": \"application/jsonl\"}) iterator = jsonl.load(req) print(tuple(iterator)) Load a file containing broken lines. Warning If the broken parameter is set to False , the function will raise an Exception when it encounters a broken line. If set to True , the function will skip the broken line, continue reading the file, and log a warning message. import jsonl # Create a file with broken JSON lines with open(\"file.jsonl\", mode=\"wt\", encoding=\"utf-8\") as fp: fp.write('{\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}\\n') fp.write('{\"name\": \"May\", \"wins\": []\\n') # missing closing bracket fp.write('{\"name\": \"Richard\", \"wins\": []}\\n') # Load the jsonl file, skipping broken lines iterator = jsonl.load(\"file.jsonl\", broken=True) print(tuple(iterator)) Output: WARNING:root:Broken line at 2: Expecting ',' delimiter: line 2 column 1 (char 28) ({'name': 'Gilbert', 'wins': [['straight', '7\u2663'], ['one pair', '10\u2665']]}, {'name': 'Richard', 'wins': []}) Load a file using a custom deserialization. The json_loads parameter allows for custom deserialization and must take a JSON-formatted string as input and return a Python object. Tip Commonly, libraries like orjson or ujson are used for faster performance, or you can implement your own custom deserialization function for specific needs. The following example demonstrates how to use the json_loads parameter to deserialize the data using the orjson and ujson libraries. Make sure to install these libraries to run the example. pip install orjson ujson # Ignore this command if these libraries are already installed. Now, you can use these libraries to load the JSON lines: import orjson import ujson import jsonl path = \"file.jsonl\" # Example data to save in the file data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the jsonl file jsonl.dump(data, path) # Load the file using ujson iterator1 = jsonl.load(path, json_loads=ujson.loads) # Load the file using orjson iterator2 = jsonl.load(path, json_loads=orjson.loads) print(tuple(iterator1)) print(tuple(iterator2)) Load a file using a custom opener. The opener parameter allows loading files from custom sources, such as a ZIP archive. Here\u2019s how to use it: import zipfile import jsonl # Create a ZIP file containing a jsonlines file zip_path = \"data.zip\" jsonl_path = \"file.jsonl\" data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the jsonl file jsonl.dump(data, jsonl_path) # Create a ZIP file and add the jsonl file to it with zipfile.ZipFile(zip_path, 'w') as zf: zf.write(jsonl_path) # Define a custom opener function to read from the ZIP file def opener(name, *args, **kwargs): return zipfile.ZipFile(name).open(jsonl_path) # Load the jsonl file from the ZIP archive using the opener iterator = jsonl.load(zip_path, opener=opener) print(tuple(iterator))","title":"Load jsonlines file"},{"location":"load/#load-json-lines-files","text":"Load JSON Lines (jsonl) files incrementally, supporting both uncompressed and compressed formats, handling broken lines, and allowing custom deserialization and opener callbacks. It also allows loading from URLs and urllib requests. Note Supported compression formats are: gzip (.gz), bzip2 (.bz2), xz (.xz) If a file extension is not provided or is unrecognized, the file will be assumed to be uncompressed.","title":"Load JSON Lines files"},{"location":"load/#load-an-uncompressed-file-given-a-path","text":"import jsonl path = \"file.jsonl\" # Example data to save in the file data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the jsonl file jsonl.dump(data, path) # Load the file as an iterator iterator = jsonl.load(path) print(tuple(iterator))","title":"Load an uncompressed file given a path."},{"location":"load/#load-a-compressed-file-given-a-path","text":"Check note for more details import jsonl path = \"file.jsonl.gz\" # gzip compressed file, but it can be \".bz2\" or \".xz\" # Example data to save in the file data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the compressed jsonl file jsonl.dump(data, path) # Load the compressed file as an iterator iterator = jsonl.load(path) print(tuple(iterator))","title":"Load a compressed file given a path."},{"location":"load/#load-a-file-from-an-open-file-object","text":"Tip This is useful when you need to load a file from a custom source. import jsonl path = \"file.jsonl\" # Example data to save in the file data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the compressed jsonl file jsonl.dump(data, path) # Load the file using an open file object with open(path) as fp: iterator = jsonl.load(fp) print(tuple(iterator))","title":"Load a file from an open file object."},{"location":"load/#load-from-a-url","text":"You can load a JSON Lines directly from a URL incrementally, if needed you can also create custom requests using urllib.request.Request . import urllib.request import jsonl # Load data from a URL iterator = jsonl.load(\"https://example.com\") print(tuple(iterator)) # Load data from a urllib request to handle custom requests req = urllib.request.Request(\"https://example.com\", headers={\"Accept\": \"application/jsonl\"}) iterator = jsonl.load(req) print(tuple(iterator))","title":"Load from a URL."},{"location":"load/#load-a-file-containing-broken-lines","text":"Warning If the broken parameter is set to False , the function will raise an Exception when it encounters a broken line. If set to True , the function will skip the broken line, continue reading the file, and log a warning message. import jsonl # Create a file with broken JSON lines with open(\"file.jsonl\", mode=\"wt\", encoding=\"utf-8\") as fp: fp.write('{\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}\\n') fp.write('{\"name\": \"May\", \"wins\": []\\n') # missing closing bracket fp.write('{\"name\": \"Richard\", \"wins\": []}\\n') # Load the jsonl file, skipping broken lines iterator = jsonl.load(\"file.jsonl\", broken=True) print(tuple(iterator)) Output: WARNING:root:Broken line at 2: Expecting ',' delimiter: line 2 column 1 (char 28) ({'name': 'Gilbert', 'wins': [['straight', '7\u2663'], ['one pair', '10\u2665']]}, {'name': 'Richard', 'wins': []})","title":"Load a file containing broken lines."},{"location":"load/#load-a-file-using-a-custom-deserialization","text":"The json_loads parameter allows for custom deserialization and must take a JSON-formatted string as input and return a Python object. Tip Commonly, libraries like orjson or ujson are used for faster performance, or you can implement your own custom deserialization function for specific needs. The following example demonstrates how to use the json_loads parameter to deserialize the data using the orjson and ujson libraries. Make sure to install these libraries to run the example. pip install orjson ujson # Ignore this command if these libraries are already installed. Now, you can use these libraries to load the JSON lines: import orjson import ujson import jsonl path = \"file.jsonl\" # Example data to save in the file data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the jsonl file jsonl.dump(data, path) # Load the file using ujson iterator1 = jsonl.load(path, json_loads=ujson.loads) # Load the file using orjson iterator2 = jsonl.load(path, json_loads=orjson.loads) print(tuple(iterator1)) print(tuple(iterator2))","title":"Load a file using a custom deserialization."},{"location":"load/#load-a-file-using-a-custom-opener","text":"The opener parameter allows loading files from custom sources, such as a ZIP archive. Here\u2019s how to use it: import zipfile import jsonl # Create a ZIP file containing a jsonlines file zip_path = \"data.zip\" jsonl_path = \"file.jsonl\" data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the jsonl file jsonl.dump(data, jsonl_path) # Create a ZIP file and add the jsonl file to it with zipfile.ZipFile(zip_path, 'w') as zf: zf.write(jsonl_path) # Define a custom opener function to read from the ZIP file def opener(name, *args, **kwargs): return zipfile.ZipFile(name).open(jsonl_path) # Load the jsonl file from the ZIP archive using the opener iterator = jsonl.load(zip_path, opener=opener) print(tuple(iterator))","title":"Load a file using a custom opener."},{"location":"load_archive/","text":"Load multiple JSON Lines Files from an Archive (ZIP or TAR) incrementally Allows to load multiple JSON Lines (.jsonl) files incrementally from a ZIP or TAR archive. Support compressed TAR archives (e.g., .tar.gz , .tar.bz2 , .tar.xz ). Support ZIP archives with password protection. Filename filtering using Unix shell-style wildcards via fnmatch . Use a pattern (e.g., *.jsonl) to selectively load only matching files within the archive. Support for both compressed and uncompressed .jsonl files inside the archive. (e.g., *.jsonl.gz or *.jsonl.bz2 or *.jsonl.xz ). Graceful handling of malformed or broken lines. Optional custom deserialization and opener callbacks for advanced use cases. Example usage: import jsonl path = \"path/to/archive.zip\" # Load all JSON Lines files matching the pattern \"*.jsonl\" from the archive for filename, iterator in jsonl.load_archive(path): print(\"Filename:\", filename) print(\"Data:\", tuple(iterator)) ZIP password protection load_archive can read password-protected ZIP archives. To do so, you need to provide a password argument: import jsonl path = \"path/to/protected.zip\" for filename, iterator in jsonl.load_archive(path, password=b\"your_password\"): print(\"Filename:\", filename) print(\"Data:\", tuple(iterator)) Pattern matching You can use Unix shell-style wildcards to filter files in the archive. The pattern argument supports: * matches everything ? matches a single character [seq] matches any character in seq [!seq] matches any character not in seq For more information, refer to the fnmatch documentation . import jsonl path = \"path/to/archive.zip\" # Load all JSON Lines files matching the pattern \"myfile*.jsonl\" from the archive for filename, iterator in jsonl.load_archive(path, pattern=\"myfile*.jsonl\"): print(\"Filename:\", filename) print(\"Data:\", tuple(iterator))","title":"Load archive files"},{"location":"load_archive/#load-multiple-json-lines-files-from-an-archive-zip-or-tar-incrementally","text":"Allows to load multiple JSON Lines (.jsonl) files incrementally from a ZIP or TAR archive. Support compressed TAR archives (e.g., .tar.gz , .tar.bz2 , .tar.xz ). Support ZIP archives with password protection. Filename filtering using Unix shell-style wildcards via fnmatch . Use a pattern (e.g., *.jsonl) to selectively load only matching files within the archive. Support for both compressed and uncompressed .jsonl files inside the archive. (e.g., *.jsonl.gz or *.jsonl.bz2 or *.jsonl.xz ). Graceful handling of malformed or broken lines. Optional custom deserialization and opener callbacks for advanced use cases. Example usage: import jsonl path = \"path/to/archive.zip\" # Load all JSON Lines files matching the pattern \"*.jsonl\" from the archive for filename, iterator in jsonl.load_archive(path): print(\"Filename:\", filename) print(\"Data:\", tuple(iterator))","title":"Load multiple JSON Lines Files from an Archive (ZIP or TAR) incrementally"},{"location":"load_archive/#zip-password-protection","text":"load_archive can read password-protected ZIP archives. To do so, you need to provide a password argument: import jsonl path = \"path/to/protected.zip\" for filename, iterator in jsonl.load_archive(path, password=b\"your_password\"): print(\"Filename:\", filename) print(\"Data:\", tuple(iterator))","title":"ZIP password protection"},{"location":"load_archive/#pattern-matching","text":"You can use Unix shell-style wildcards to filter files in the archive. The pattern argument supports: * matches everything ? matches a single character [seq] matches any character in seq [!seq] matches any character not in seq For more information, refer to the fnmatch documentation . import jsonl path = \"path/to/archive.zip\" # Load all JSON Lines files matching the pattern \"myfile*.jsonl\" from the archive for filename, iterator in jsonl.load_archive(path, pattern=\"myfile*.jsonl\"): print(\"Filename:\", filename) print(\"Data:\", tuple(iterator))","title":"Pattern matching"}]}