{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"jsonl About jsonl is a library that includes useful tools for working with jsonlines data as described jsonlines Features: \ud83c\udf0e Provides an API similar to Python's standard json module. \ud83d\ude80 Supports custom serialization/deserialization callbacks, with the standard json module as the default. \ud83d\udddc\ufe0f Supports compression and decompression using gzip , bzip2 , and xz formats. \ud83d\udd27 Can load files with broken lines, skipping any malformed entries. \ud83d\udce6 Includes an easy-to-use utility for incrementally writing to multiple JSON Lines files. Installation (via pip) pip install py-jsonl","title":"Introduction"},{"location":"#jsonl","text":"","title":"jsonl"},{"location":"#about","text":"jsonl is a library that includes useful tools for working with jsonlines data as described jsonlines Features: \ud83c\udf0e Provides an API similar to Python's standard json module. \ud83d\ude80 Supports custom serialization/deserialization callbacks, with the standard json module as the default. \ud83d\udddc\ufe0f Supports compression and decompression using gzip , bzip2 , and xz formats. \ud83d\udd27 Can load files with broken lines, skipping any malformed entries. \ud83d\udce6 Includes an easy-to-use utility for incrementally writing to multiple JSON Lines files.","title":"About"},{"location":"#installation-via-pip","text":"pip install py-jsonl","title":"Installation (via pip)"},{"location":"changes/","text":"Can see changes here","title":"Changes"},{"location":"dump/","text":"Dump an iterable to a JSON Lines file incrementally. Dump JSON Lines (jsonl) files incrementally, supporting both uncompressed and compressed formats and allowing custom serialization and opener callbacks. Dump the data to an uncompressed file at the specified path. import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] jsonl.dump(data, \"file.jsonl\") Dump the data to a compressed file at the specified path. Note Supported compression formats are: gzip (.gz), bzip2 (.bz2), xz (.xz) If a file extension is not provided or is unrecognized, the file will be assumed to be uncompressed. import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Dump to a gzip compressed file. jsonl.dump(data, \"file.jsonl.gz\") # Dump to a bzip2 compressed file. jsonl.dump(data, \"file.jsonl.bz2\") # Dump to a xz compressed file. jsonl.dump(data, \"file.jsonl.xz\") # Dump to a text file because the extension is not recognized. jsonl.dump(data, \"file.jsonl.foo\") Dump the data to the already opened file. import gzip import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Dump to an opened file, Text mode is True because it is a text file. with open(\"file.jsonl\", mode=\"wt\", encoding=\"utf-8\") as fd: jsonl.dump(data, fd, text_mode=True) # Dump to an opened gzip file, Text mode is false because it is a binary file. with gzip.open(\"file.jsonl.gz\", mode=\"wb\") as fd: jsonl.dump(data, fd, text_mode=False) Append the data to the end of the existing file. import gzip import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Compressed file: Text mode is false because it is a binary file. with gzip.open(\"file.jsonl.gz\", mode=\"ab\") as fp: jsonl.dump(data, fp, text_mode=False) # Uncompressed file: Text mode is true because it is a text file. with open(\"file.jsonl\", mode=\"at\", encoding=\"utf-8\") as fp: jsonl.dump(data, fp, text_mode=True) Dump the data to a custom file object. Tip Use this feature when you need to write the data to a custom file object. The custom file object must have a write or writelines method. import jsonl class MyCustomFile1: \"\"\"A custom file object that has a write method.\"\"\" def write(self, line): print(line) class MyCustomFile2: \"\"\"A custom file object that has a writelines method.\"\"\" def writelines(self, lines): print(\"\".join(lines)) data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Dump the data to the custom file object using the write method. jsonl.dump(data, MyCustomFile1(), text_mode=True) # Dump the data to the custom file object using the writelines method. jsonl.dump(data, MyCustomFile2(), text_mode=True) Dump data with a custom serialization. The json_dumps parameter allows for custom serialization and must take a Python object and return a JSON-formatted string. The following example shows how to use the json_dumps parameter to serialize data with the orjson and ujson libraries. Make sure to install these libraries to run the example. pip install orjson ujson # Ignore this command if these libraries are already installed. import orjson import ujson import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Dump the data using the ujson library. jsonl.dump(data, \"foo.jsonl\", json_dumps=ujson.dumps, ensure_ascii=False) # Dump the data using the orjson library. jsonl.dump(data, \"var.jsonl\", json_dumps=orjson.dumps) # Dumping data into a JSON file with compact output using separators (',', ':') # to remove unnecessary whitespaces. jsonl.dump(data, \"bar.jsonl\", separators=(',', ':'))","title":"Dump to a jsonlines file"},{"location":"dump/#dump-an-iterable-to-a-json-lines-file-incrementally","text":"Dump JSON Lines (jsonl) files incrementally, supporting both uncompressed and compressed formats and allowing custom serialization and opener callbacks.","title":"Dump an iterable to a JSON Lines file incrementally."},{"location":"dump/#dump-the-data-to-an-uncompressed-file-at-the-specified-path","text":"import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] jsonl.dump(data, \"file.jsonl\")","title":"Dump the data to an uncompressed file at the specified path."},{"location":"dump/#dump-the-data-to-a-compressed-file-at-the-specified-path","text":"Note Supported compression formats are: gzip (.gz), bzip2 (.bz2), xz (.xz) If a file extension is not provided or is unrecognized, the file will be assumed to be uncompressed. import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Dump to a gzip compressed file. jsonl.dump(data, \"file.jsonl.gz\") # Dump to a bzip2 compressed file. jsonl.dump(data, \"file.jsonl.bz2\") # Dump to a xz compressed file. jsonl.dump(data, \"file.jsonl.xz\") # Dump to a text file because the extension is not recognized. jsonl.dump(data, \"file.jsonl.foo\")","title":"Dump the data to a compressed file at the specified path."},{"location":"dump/#dump-the-data-to-the-already-opened-file","text":"import gzip import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Dump to an opened file, Text mode is True because it is a text file. with open(\"file.jsonl\", mode=\"wt\", encoding=\"utf-8\") as fd: jsonl.dump(data, fd, text_mode=True) # Dump to an opened gzip file, Text mode is false because it is a binary file. with gzip.open(\"file.jsonl.gz\", mode=\"wb\") as fd: jsonl.dump(data, fd, text_mode=False)","title":"Dump the data to the already opened file."},{"location":"dump/#append-the-data-to-the-end-of-the-existing-file","text":"import gzip import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Compressed file: Text mode is false because it is a binary file. with gzip.open(\"file.jsonl.gz\", mode=\"ab\") as fp: jsonl.dump(data, fp, text_mode=False) # Uncompressed file: Text mode is true because it is a text file. with open(\"file.jsonl\", mode=\"at\", encoding=\"utf-8\") as fp: jsonl.dump(data, fp, text_mode=True)","title":"Append the data to the end of the existing file."},{"location":"dump/#dump-the-data-to-a-custom-file-object","text":"Tip Use this feature when you need to write the data to a custom file object. The custom file object must have a write or writelines method. import jsonl class MyCustomFile1: \"\"\"A custom file object that has a write method.\"\"\" def write(self, line): print(line) class MyCustomFile2: \"\"\"A custom file object that has a writelines method.\"\"\" def writelines(self, lines): print(\"\".join(lines)) data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Dump the data to the custom file object using the write method. jsonl.dump(data, MyCustomFile1(), text_mode=True) # Dump the data to the custom file object using the writelines method. jsonl.dump(data, MyCustomFile2(), text_mode=True)","title":"Dump the data to a custom file object."},{"location":"dump/#dump-data-with-a-custom-serialization","text":"The json_dumps parameter allows for custom serialization and must take a Python object and return a JSON-formatted string. The following example shows how to use the json_dumps parameter to serialize data with the orjson and ujson libraries. Make sure to install these libraries to run the example. pip install orjson ujson # Ignore this command if these libraries are already installed. import orjson import ujson import jsonl data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Dump the data using the ujson library. jsonl.dump(data, \"foo.jsonl\", json_dumps=ujson.dumps, ensure_ascii=False) # Dump the data using the orjson library. jsonl.dump(data, \"var.jsonl\", json_dumps=orjson.dumps) # Dumping data into a JSON file with compact output using separators (',', ':') # to remove unnecessary whitespaces. jsonl.dump(data, \"bar.jsonl\", separators=(',', ':'))","title":"Dump data with a custom serialization."},{"location":"dump_fork/","text":"Dump to multiple jsonlines files Dump multiple iterables incrementally to the specified jsonlines file paths, optimizing memory usage. The files can be compressed using gzip , bzip2 , or xz formats. If the file extension is not recognized, it will be dumped to a text file. Example #1 This example uses jsonl.dump_fork to incrementally write daily temperature data for multiple cities to separate JSON Lines files, exporting records for the first days of specified years. It efficiently manages data by creating individual files for each city, optimizing memory usage. import datetime import itertools import random import jsonl def get_temperature_by_city(): \"\"\" Generates files for each city with daily temperature data for the initial days of the specified years. \"\"\" years = [2023, 2024] first_days = 10 cities = [\"New York\", \"Los Angeles\", \"Chicago\"] for year, city in itertools.product(years, cities): start = datetime.datetime(year, 1, 1) dates = (start + datetime.timedelta(days=day) for day in range(first_days)) daily_temperature = ( {\"date\": date.isoformat(), \"city\": city, \"temperature\": round(random.uniform(-10, 35), 2)} for date in dates ) yield (f\"{city}.jsonl\", daily_temperature) # Write the generated data to files in JSON Lines format jsonl.dump_fork(get_temperature_by_city()) Example #2 This example demonstrates how to dump data using different JSON libraries. You can install orjson and ujson to run the following example. pip install orjson ujson # Ignore this command if these libraries are already installed. import orjson import ujson import jsonl def worker(): yield (\"num.jsonl\", ({\"value\": 1}, {\"value\": 2})) yield (\"foo.jsonl\", iter(({\"a\": \"1\"}, {\"b\": 2}))) yield (\"num.jsonl\", [{\"value\": 3}]) yield (\"foo.jsonl\", ()) # Dump the data using the default json.dumps function. jsonl.dump_fork(worker()) # Dump the data using the ujson library. jsonl.dump_fork(worker(), json_dumps=ujson.dumps, ensure_ascii=False) # Dump the data using the orjson library. jsonl.dump_fork(worker(), json_dumps=orjson.dumps) # using (orjson)","title":"Dump to multiple jsonlines files"},{"location":"dump_fork/#dump-to-multiple-jsonlines-files","text":"Dump multiple iterables incrementally to the specified jsonlines file paths, optimizing memory usage. The files can be compressed using gzip , bzip2 , or xz formats. If the file extension is not recognized, it will be dumped to a text file. Example #1 This example uses jsonl.dump_fork to incrementally write daily temperature data for multiple cities to separate JSON Lines files, exporting records for the first days of specified years. It efficiently manages data by creating individual files for each city, optimizing memory usage. import datetime import itertools import random import jsonl def get_temperature_by_city(): \"\"\" Generates files for each city with daily temperature data for the initial days of the specified years. \"\"\" years = [2023, 2024] first_days = 10 cities = [\"New York\", \"Los Angeles\", \"Chicago\"] for year, city in itertools.product(years, cities): start = datetime.datetime(year, 1, 1) dates = (start + datetime.timedelta(days=day) for day in range(first_days)) daily_temperature = ( {\"date\": date.isoformat(), \"city\": city, \"temperature\": round(random.uniform(-10, 35), 2)} for date in dates ) yield (f\"{city}.jsonl\", daily_temperature) # Write the generated data to files in JSON Lines format jsonl.dump_fork(get_temperature_by_city()) Example #2 This example demonstrates how to dump data using different JSON libraries. You can install orjson and ujson to run the following example. pip install orjson ujson # Ignore this command if these libraries are already installed. import orjson import ujson import jsonl def worker(): yield (\"num.jsonl\", ({\"value\": 1}, {\"value\": 2})) yield (\"foo.jsonl\", iter(({\"a\": \"1\"}, {\"b\": 2}))) yield (\"num.jsonl\", [{\"value\": 3}]) yield (\"foo.jsonl\", ()) # Dump the data using the default json.dumps function. jsonl.dump_fork(worker()) # Dump the data using the ujson library. jsonl.dump_fork(worker(), json_dumps=ujson.dumps, ensure_ascii=False) # Dump the data using the orjson library. jsonl.dump_fork(worker(), json_dumps=orjson.dumps) # using (orjson)","title":"Dump to multiple jsonlines files"},{"location":"dumps/","text":"Serialize an iterable into a JSON Lines formatted string. import jsonl data = ({'foo': 1}, {'bar': 2}) result = jsonl.dumps(data) print(result)","title":"Dump to a string"},{"location":"dumps/#serialize-an-iterable-into-a-json-lines-formatted-string","text":"import jsonl data = ({'foo': 1}, {'bar': 2}) result = jsonl.dumps(data) print(result)","title":"Serialize an iterable into a JSON Lines formatted string."},{"location":"installation/","text":"Installation Install jsonl via pip: pip install py-jsonl","title":"Installation"},{"location":"installation/#installation","text":"Install jsonl via pip: pip install py-jsonl","title":"Installation"},{"location":"load/","text":"Load JSON Lines files Load JSON Lines (jsonl) files incrementally, supporting both uncompressed and compressed formats, handling broken lines, and allowing custom deserialization and opener callbacks. Note Supported compression formats are: gzip (.gz), bzip2 (.bz2), xz (.xz) If a file extension is not provided or is unrecognized, the file will be assumed to be uncompressed. Load an uncompressed file given a path. import jsonl path = \"file.jsonl\" # Example data to save in the file data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the jsonl file jsonl.dump(data, path) # Load the file as an iterable iterable = jsonl.load(path) print(tuple(iterable)) Load a compressed file given a path. Check note for more details import jsonl path = \"file.jsonl.gz\" # gzip compressed file, but it can be \".bz2\" or \".xz\" # Example data to save in the file data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the compressed jsonl file jsonl.dump(data, path) # Load the compressed file as an iterable iterable = jsonl.load(path) print(tuple(iterable)) Load a file from an open file object. Tip This is useful when you need to load a file from a custom source. import jsonl path = \"file.jsonl\" # Example data to save in the file data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the compressed jsonl file jsonl.dump(data, path) # Load the file using an open file object with open(path) as fp: iterable = jsonl.load(fp) print(tuple(iterable)) Load a file containing broken lines. Warning If the broken parameter is set to False , the function will raise an Exception when it encounters a broken line. If set to True , the function will skip the broken line, continue reading the file, and log a warning message. import jsonl # Create a file with broken JSON lines with open(\"file.jsonl\", mode=\"wt\", encoding=\"utf-8\") as fp: fp.write('{\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}\\n') fp.write('{\"name\": \"May\", \"wins\": []\\n') # missing closing bracket fp.write('{\"name\": \"Richard\", \"wins\": []}\\n') # Load the jsonl file, skipping broken lines iterable = jsonl.load(\"file.jsonl\", broken=True) print(tuple(iterable)) Output: WARNING:root:Broken line at 2: Expecting ',' delimiter: line 2 column 1 (char 28) ({'name': 'Gilbert', 'wins': [['straight', '7\u2663'], ['one pair', '10\u2665']]}, {'name': 'Richard', 'wins': []}) Load a file using a custom deserialization. The json_loads parameter allows for custom deserialization and must take a JSON-formatted string as input and return a Python object. Tip Commonly, libraries like orjson or ujson are used for faster performance, or you can implement your own custom deserialization function for specific needs. The following example demonstrates how to use the json_loads parameter to deserialize the data using the orjson and ujson libraries. Make sure to install these libraries to run the example. pip install orjson ujson # Ignore this command if these libraries are already installed. Now, you can use these libraries to load the JSON lines: import orjson import ujson import jsonl path = \"file.jsonl\" # Example data to save in the file data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the jsonl file jsonl.dump(data, path) # Load the file using ujson iterable1 = jsonl.load(path, json_loads=ujson.loads) # Load the file using orjson iterable2 = jsonl.load(path, json_loads=orjson.loads) print(tuple(iterable1)) print(tuple(iterable2)) Load a file using a custom opener. The opener parameter allows loading files from custom sources, such as a ZIP archive. Here\u2019s how to use it: import zipfile import jsonl # Create a ZIP file containing a jsonlines file zip_path = \"data.zip\" jsonl_path = \"file.jsonl\" data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the jsonl file jsonl.dump(data, jsonl_path) # Create a ZIP file and add the jsonl file to it with zipfile.ZipFile(zip_path, 'w') as zf: zf.write(jsonl_path) # Define a custom opener function to read from the ZIP file def opener(name, *args, **kwargs): return zipfile.ZipFile(name).open(jsonl_path) # Load the jsonl file from the ZIP archive using the opener iterable = jsonl.load(zip_path, opener=opener) print(tuple(iterable))","title":"Load jsonlines file"},{"location":"load/#load-json-lines-files","text":"Load JSON Lines (jsonl) files incrementally, supporting both uncompressed and compressed formats, handling broken lines, and allowing custom deserialization and opener callbacks. Note Supported compression formats are: gzip (.gz), bzip2 (.bz2), xz (.xz) If a file extension is not provided or is unrecognized, the file will be assumed to be uncompressed.","title":"Load JSON Lines files"},{"location":"load/#load-an-uncompressed-file-given-a-path","text":"import jsonl path = \"file.jsonl\" # Example data to save in the file data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the jsonl file jsonl.dump(data, path) # Load the file as an iterable iterable = jsonl.load(path) print(tuple(iterable))","title":"Load an uncompressed file given a path."},{"location":"load/#load-a-compressed-file-given-a-path","text":"Check note for more details import jsonl path = \"file.jsonl.gz\" # gzip compressed file, but it can be \".bz2\" or \".xz\" # Example data to save in the file data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the compressed jsonl file jsonl.dump(data, path) # Load the compressed file as an iterable iterable = jsonl.load(path) print(tuple(iterable))","title":"Load a compressed file given a path."},{"location":"load/#load-a-file-from-an-open-file-object","text":"Tip This is useful when you need to load a file from a custom source. import jsonl path = \"file.jsonl\" # Example data to save in the file data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the compressed jsonl file jsonl.dump(data, path) # Load the file using an open file object with open(path) as fp: iterable = jsonl.load(fp) print(tuple(iterable))","title":"Load a file from an open file object."},{"location":"load/#load-a-file-containing-broken-lines","text":"Warning If the broken parameter is set to False , the function will raise an Exception when it encounters a broken line. If set to True , the function will skip the broken line, continue reading the file, and log a warning message. import jsonl # Create a file with broken JSON lines with open(\"file.jsonl\", mode=\"wt\", encoding=\"utf-8\") as fp: fp.write('{\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}\\n') fp.write('{\"name\": \"May\", \"wins\": []\\n') # missing closing bracket fp.write('{\"name\": \"Richard\", \"wins\": []}\\n') # Load the jsonl file, skipping broken lines iterable = jsonl.load(\"file.jsonl\", broken=True) print(tuple(iterable)) Output: WARNING:root:Broken line at 2: Expecting ',' delimiter: line 2 column 1 (char 28) ({'name': 'Gilbert', 'wins': [['straight', '7\u2663'], ['one pair', '10\u2665']]}, {'name': 'Richard', 'wins': []})","title":"Load a file containing broken lines."},{"location":"load/#load-a-file-using-a-custom-deserialization","text":"The json_loads parameter allows for custom deserialization and must take a JSON-formatted string as input and return a Python object. Tip Commonly, libraries like orjson or ujson are used for faster performance, or you can implement your own custom deserialization function for specific needs. The following example demonstrates how to use the json_loads parameter to deserialize the data using the orjson and ujson libraries. Make sure to install these libraries to run the example. pip install orjson ujson # Ignore this command if these libraries are already installed. Now, you can use these libraries to load the JSON lines: import orjson import ujson import jsonl path = \"file.jsonl\" # Example data to save in the file data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the jsonl file jsonl.dump(data, path) # Load the file using ujson iterable1 = jsonl.load(path, json_loads=ujson.loads) # Load the file using orjson iterable2 = jsonl.load(path, json_loads=orjson.loads) print(tuple(iterable1)) print(tuple(iterable2))","title":"Load a file using a custom deserialization."},{"location":"load/#load-a-file-using-a-custom-opener","text":"The opener parameter allows loading files from custom sources, such as a ZIP archive. Here\u2019s how to use it: import zipfile import jsonl # Create a ZIP file containing a jsonlines file zip_path = \"data.zip\" jsonl_path = \"file.jsonl\" data = [ {\"name\": \"Gilbert\", \"wins\": [[\"straight\", \"7\u2663\"], [\"one pair\", \"10\u2665\"]]}, {\"name\": \"May\", \"wins\": []}, ] # Save the data to the jsonl file jsonl.dump(data, jsonl_path) # Create a ZIP file and add the jsonl file to it with zipfile.ZipFile(zip_path, 'w') as zf: zf.write(jsonl_path) # Define a custom opener function to read from the ZIP file def opener(name, *args, **kwargs): return zipfile.ZipFile(name).open(jsonl_path) # Load the jsonl file from the ZIP archive using the opener iterable = jsonl.load(zip_path, opener=opener) print(tuple(iterable))","title":"Load a file using a custom opener."}]}